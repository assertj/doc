[[user-guide]]
= AssertJ User Guide

This is now the official site for AssertJ Core replacing: http://joel-costigliola.github.io/assertj/assertj-core.html

The migration from the old site is still in progress but this new site already contains useful information and even some not documented previously!

If you feel something is missing or not clear enough, please raise an issue in https://github.com/assertj/doc/issues or even better contribute to it!

:imagesdir: images
:imagesoutdir: {outdir}/user-guide/images
//
ifdef::backend-pdf[:imagesdir: {imagesoutdir}]
//
:sectnums:
//

include::../link-attributes.adoc[]

include::overview.adoc[]

include::assertions-guide.adoc[]

include::contributors.adoc[]

[[release-notes]]
== Release Notes

=== AssertJ Core

Latest release notes:

- link:#assertj-core-3-13-0-release-notes[AssertJ Core 3.13.0 release notes]
- link:#assertj-core-3-12-2-release-notes[AssertJ Core 3.12.2 release notes]
- link:#assertj-core-3-12-1-release-notes[AssertJ Core 3.12.1 release notes]
- link:#assertj-core-3-12-0-release-notes[AssertJ Core 3.12.0 release notes]

==== AssertJ Core 3.13.0 Release notes

Release date : 2019-07-xx

The highlight of this release is the addition of `asInstanceOf` which allows to chain specific type assertions from a value that was initially declared with a different type (usually `Object`). Thanks Stefano Cordio for this contribution!.

Example:
[source,java,indent=0]
----
Object value = "abc";

// This line DOES NOT COMPILE since startsWith is a String assertion and value is an Object
assertThat(value).startsWith("ab");

// This line COMPILES because we tell AssertJ to consider value as a String
assertThat(value).asInstanceOf(InstanceOfAssertFactories.STRING).startsWith("ab");
----
This feature is more detailed in the notes below.

===== Contributors

Thanks to all the contributors of this release:

Pascal Schumacher, Erhard Pointl, Stefano Cordio, Thomas Traude, Andrei Solntsev, Matej Drobnič, Željko Mirović, Mike Gilchrist, Phillip Webb, Michal Fotyga,Valeriy Vyrva, Eddú Meléndez Gonzales, GaspardPO, Bengt Brodersen, Jiri Pejchal, Christian Stein, Nikolaos Georgiou and Sam Brannen.

Special thanks to Nils Winkler for his work on the assertions convertion scripts and Stefano Cordio for the `asInstanceOf` contribution.

[[assertj-core-3.13.0-breaking-changes]]
===== Breaking changes

In the new recursive comparison, we now use the expected field as a reference to determine how to compare it to corresponding the actual field.
Sorted vs non sorted collections comparison semantics have been replaced by ordered vs unordered collections semantics (ordered types are `List`, `SortedSet` and `LinkedHashSet`).
As a consequence of the two previous points, when comparing collection/map fields, if the actual field is ordered and the expected is unordered, the comparison is allowed but not the other way around (unless order is ignored explicitely in the comparison configuration).

===== New features

- Add link:#assertj-core-3.13.0-asInstanceOf[`asInstanceOf`] to chain specific type assertions. (Stefano Cordio)
- Add link:#assertj-core-3.13.0-extracting[`extracting(String)`] to `Object` and `Map` assertions. (Stefano Cordio)
- Add a way to link:#assertj-core-3.13.0-global-configuration[configure AssertJ] for all tests.
- Add link:#assertj-core-3.13.0-hasCauseReference[`hasCauseReference`] throwable assertion. (Mike Gilchrist)
- Add link:#assertj-core-3.13.0-directory-assertions[directory content assertions] for `File` and `Path`. (Valeriy Vyrva)
- Add link:#assertj-core-3.13.0-throwable-message-assertions[`hasMessageContainingAll` and `hasMessageNotContainingAny`] to throwable assertions. (Phillip Webb)
- Allow using any link:#assertj-core-3.13.0-check-soft-assertions-with-any-custom-assertions[custom assertions in soft assertions]. (Bengt Brodersen)
- Add link:#assertj-core-3.13.0-containsExactlyInAnyOrderEntriesOf[`containsExactlyInAnyOrderEntriesOf`] to map assertions. (Stefano Cordio)
- Add link:#assertj-core-3.13.0-isCloseToUtcNow[`isCloseToUtcNow`] to `LocalDateTime` and `OffsetDateTime` assertions. (Nikolaos Georgiou)

===== Improvements

- Junit 4/5 and TestNG assertions convertion scripts improvements. (Nils Winkler)
- Add support for link:#assertj-core-3.13.0-millisecond-and-timezone-parsing[combined millisecond and timezone parsing]. (Matej Drobnič)
- Add support for link:#assertj-core-3.13.0-optional-support-in-recursive-comparison[`Optional` in the new recursive comparison].
- Allow link:#assertj-core-3.13.0-ignore-order-in-recursive-comparison[ignoring collection order] in specific fields in the new recursive comparison. (Željko Mirović)
- Make `catchThrowableOfType` easier to discover in the javadoc.
- Rename methods `isBeforeOrEqualsTo` and `isAfterOrEqualsTo` to `isBeforeOrEqualTo` and `isAfterOrEqualTo`. (Eddú Meléndez Gonzales)
- Improve error messages in the new recursive comparison when group size differs or when trying to compare actual unordered vs expected ordered.
- Introduce explicit module descriptor. (Christian Stein)
- Allow returned values of `WithAssertions#fail` methods to be ignored by findbugs/spotbugs. (Jiri Pejchal)
- Improve the error message when multiple (soft) assertions error are raised.

===== Fixed

- Fix link:index.html#assertj-core-junit5-soft-assertions[Soft assertions JUnit 5 extension] that did not support parallel test nor `@TestInstance(PER_CLASS)` lifecycle semantics. (Sam Brannen)
- Fix JavaDoc regarding `AnyOf` and `AllOf`. (Thomas Traude)
- Make sure that `isEqualTo("abc")` is not resolved to `isEqualTo(String, Object... args)`. (Andrei Solntsev)
- Fix Javadoc typos. (GaspardPO, Michal Fotyga)
- Fix typo in error message factories `ShouldBeBeforeOrEqualTo` and `ShouldBeAfterOrEqualTo`. (Stefano Cordio)

===== Deprecated

- Deprecate Java 6/Android assertions entry points as they don't truly provide 100% Java 6/Android compatibility.
- Deprecate methods `isBeforeOrEqualTo` and `isAfterOrEqualTo` in favor of `isBeforeOrEqualsTo` and `isAfterOrEqualsTo` (Eddú Meléndez Gonzales).
- Deprecate `JUnitJupiterSoftAssertions` and  `JUnitJupiterBDDSoftAssertions` in favor of `SoftAssertionsExtension`

[[assertj-core-3.13.0-asInstanceOf]]
[.release-note-item]#Add `asInstanceOf` to chain specific type assertions#

`asInstanceOf` allows to chain specific type assertions from a value initially declared as a less specific type (often `Object`).

Let's start with the problem `asInstanceOf` is solving: in the following example we would like to call `String` assertions but this is not possible since `value` is declared as an `Object` thus only `Object` assertions are accessible.
[source,java,indent=0]
----
// Given a String declared as an Object
Object value = "Once upon a time in the west";

// We would like to call String assertions but this is not possible since value is declared as an Object
assertThat(value).startsWith("ab"); // this does not compile !
----

Thanks to `asInstanceOf` we can now tell AssertJ to consider `value` as a `String` in order to call `String` assertions.
To do so we need to pass an `InstanceOfAssertFactory` that can build a `StringAssert`, fortunately you don't have to write it, it is already available in `InstanceOfAssertFactories`!

[source,java,indent=0]
----
import static org.assertj.core.api.InstanceOfAssertFactories.STRING;

// Given a String declared as an Object
Object value = "Once upon a time in the west";

// With asInstanceOf, we switch to specific String assertion by specifying the InstanceOfAssertFactory for String
assertThat(value).asInstanceOf(STRING).startsWith("Once");
----

AssertJ verifies that the actual value is compatible with the assertions `InstanceOfAssertFactory` is going to give access to.

`InstanceOfAssertFactories` provides static factories for all types AssertJ provides assertions for, additional factories can be created with custom `InstanceOfAssertFactory` instances.

Here's another example showing the parameterized type support:
[source,java,indent=0]
----
// Actually a List<TolkienCharacter>
Object hobbits = list(frodo, pippin, merry, sam);

// As we specify the TolkienCharacter class, the following chained assertion expect to be given TolkienCharacters.
// This means that method like extracting or filteredOn are given a TolkienCharacter
assertThat(hobbits).asInstanceOf(InstanceOfAssertFactories.list(TolkienCharacter.class))
                   .contains(frodo, sam)
                   .extracting(TolkienCharacter::getName)
                   .contains("Frodo", "Sam");

// Use LIST if the elements type is not important but note that the chained assertions 
// will be given Object not TolkienCharacter
assertThat(hobbits).asInstanceOf(InstanceOfAssertFactories.LIST)
                    //.extracting(TolkienCharacter::getName) does not work as extracting is given an Object
                   .contains(frodo); 
----

[[assertj-core-3.13.0-extracting]]
[.release-note-item]#Add `extracting` with single parameter to `Object` and `Map` assertions#

Extracts the value of given field/property from the object under test, the extracted value becoming the new object under test.

Examples:
[source,java,indent=0]
----
// Create frodo, setting its name, age and Race (Race having a name property)
TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);

// let's extract and verify Frodo's name:
assertThat(frodo).extracting("name")
                 .isEqualTo("Frodo");

// The extracted value being a String, we would like to use String assertions but we can't due to Java generics limitations.
// The following assertion does NOT compile:
assertThat(frodo).extracting("name")
                 .startsWith("Fro");

// To get String assertions use asInstanceOf:
assertThat(frodo).extracting("name")
                 .asInstanceOf(InstanceOfAssertFactories.STRING)
                 .startsWith("Fro");
----

If the object under test is a Map, the parameter is used as a key to the map.

Example:
[source,java,indent=0]
----
Map<String, Object> basketballPlayer = new HashMap<>();
basketballPlayer.put("name", "kawhi");
basketballPlayer.put("age", 25);

// single value
assertThat(basketballPlayer).extracting("name")
                            .isEqualTo("kawhi");
----

[[assertj-core-3.13.0-global-configuration]]
[.release-note-item]#AssertJ global configuration#

AssertJ 3.13.0 introduces a `Configuration` class allowing to change AssertJ behavior and a way to register automatically. 
Read <<assertions-guide#assertj-core-configuration, Configuring AssertJ>> chapter to learn about it.


[[assertj-core-3.13.0-hasCauseReference]]
[.release-note-item]#Add `hasCauseReference` to throwable assertions#

Verifies that the actual `Throwable` has a cause that refers to the given one, i.e. using == comparison.

Example:
[source,java,indent=0]
----
Throwable invalidArgException = new IllegalArgumentException("invalid arg");
Throwable throwable = new Throwable(invalidArgException);

// This assertion succeeds:
assertThat(throwable).hasCauseReference(invalidArgException);

// These assertions fail:
assertThat(throwable).hasCauseReference(new IllegalArgumentException("invalid arg"));
assertThat(throwable).hasCauseReference(new NullPointerException());
assertThat(throwable).hasCauseReference(null); // prefer hasNoCause()
----


[[assertj-core-3.13.0-directory-assertions]]
[.release-note-item]#New directory content assertions#

The new assertions have been added for both `File` and `Path`, they add support for 

* checking what a directory contains with <<assertj-core-3.13.0-isDirectoryContaining, `isDirectoryContaining`>>
* checking what a directory does not contain with <<assertj-core-3.13.0-isDirectoryNotContaining, `isDirectoryNotContaining`>>
* checking if directory is empty with <<assertj-core-3.13.0-isEmptyDirectory, `isEmptyDirectory`>> or not with <<assertj-core-3.13.0-isNotEmptyDirectory, `isNotEmptyDirectory`>>

Both `isDirectoryContaining` and `isDirectoryNotContaining` accept either `Predicate` or `String` parameters, the `String` one being interpreted as a https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html?is-external=true#getPathMatcher(java.lang.String)[path matcher].

As `File` and `Path` assertions are similar, the examples will only show `File` assertions. 

The examples use the following directory structure:
[source,text,indent=0]
----
/root/
/root/sub-dir-1/
/root/sub-dir-1/file-1.ext
/root/sub-dir-1/file-2.ext
/root/sub-dir-2/
/root/sub-file-1.ext
/root/sub-file-2.ext
----

[[assertj-core-3.13.0-isDirectoryContaining]]
`isDirectoryContaining` assertions examples:
[source,java,indent=0]
----
File root = new File("root");

// Successfull assertions with predicate parameter:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("sub-dir"))
                .isDirectoryContaining(file -> file.getName().startsWith("sub-file"))
                .isDirectoryContaining(file -> file.getName().endsWith(".ext"))
                .isDirectoryContaining(File::isDirectory);

// Successfull assertions with String path matcher parameter:
assertThat(root).isDirectoryContaining("glob:**sub-dir*")
                .isDirectoryContaining("glob:**sub-file*")
                .isDirectoryContaining("glob:**.ext")
                .isDirectoryContaining("regex:.*ext")
                .isDirectoryContaining("glob:**.{ext,bin");


// The following assertions fail:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("dir"));
assertThat(root).isDirectoryContaining(file -> file.getName().endsWith(".bin"));
assertThat(root).isDirectoryContaining("glob:**dir");
assertThat(root).isDirectoryContaining("glob:**.bin"); 
----

[[assertj-core-3.13.0-isDirectoryNotContaining]]
`isDirectoryNotContaining` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// Successfull assertions with predicate parameter:
assertThat(root).isDirectoryNotContaining(file -> file.getName().startsWith("dir"))
                .isDirectoryNotContaining(file -> file.getName().endsWith(".bin"));

// Successfull assertions with String path matcher parameter:
assertThat(root).isDirectoryNotContaining("glob:**dir")
                .isDirectoryNotContaining("glob:**.bin")
                .isDirectoryNotContaining("regex:.*bin")
                .isDirectoryNotContaining("glob:**.{java,class}");

// The following assertions fail:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("dir"));
assertThat(root).isDirectoryContaining(file -> file.getName().endsWith(".bin")); 
assertThat(root).isDirectoryNotContaining("glob:**sub-dir*");
assertThat(root).isDirectoryNotContaining("regex:.*ext");
assertThat(root).isDirectoryNotContaining("glob:**.{ext,bin"); 
----

[[assertj-core-3.13.0-isEmptyDirectory]]
`isEmptyDirectory` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// The following assertion succeeds:
assertThat(new File(root, "sub-dir-2")).isEmptyDirectory();

// The following assertions fail:
assertThat(root).isEmptyDirectory();
assertThat(new File(root, "sub-dir-1")).isEmptyDirectory(); 
----

[[assertj-core-3.13.0-isNotEmptyDirectory]]
`isNotEmptyDirectory` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// The following assertions succeed:
assertThat(root).isNotEmptyDirectory();
assertThat(new File(root, "sub-dir-1")).isNotEmptyDirectory();

// The following assertion fails:
 assertThat(new File(root, "sub-dir-2")).isNotEmptyDirectory();
----

[[assertj-core-3.13.0-throwable-message-assertions]]
[.release-note-item]#Add `hasMessageContainingAll` and `hasMessageNotContainingAny` to throwable assertions#

These assertions are the equivalent of `hasMessageContaining` and `hasMessageNotContaining` but accepting multiple String parameters instead of only one.

Example:
[source,java,indent=0]
----
Throwable throwableWithMessage = new IllegalArgumentException("wrong amount 123");
Throwable throwableWithoutMessage = new IllegalArgumentException();

// assertion will pass:
assertThat(throwableWithMessage).hasMessageContainingAll("amount", "123")
                                .hasMessageNotContainingAny("foo", "234");

assertThat(throwableWithoutMessage).hasMessageNotContainingAny("234");

// assertions will fail:
assertThat(throwableWithMessage).hasMessageContainingAll("234");
assertThat(throwableWithoutMessage).hasMessageContainingAll("123");

assertThat(throwableWithMessage).hasMessageNotContainingAny("foo", "amount"); 
----


The same assertions have been added to `ThrowableAssertAlternative` with these names `withMessageContainingAll` and `withMessageNotContainingAny`:

[source,java,indent=0]
----
Throwable illegalArgumentException = new IllegalArgumentException("wrong amount 123");

// assertions will pass
assertThatExceptionOfType(Throwable.class)
          .isThrownBy(() -> {throw illegalArgumentException;})
          .withMessageContainingAll("amount", "123")
          .withMessageNotContainingAny("foo", "234");
----

[[assertj-core-3.13.0-check-soft-assertions-with-any-custom-assertions]]
[.release-note-item]#Allow using any custom assertions in soft assertions#

The new `check​` method catches and collect assertion errors coming from standard and custom assertions. 

Example:
[source,java,indent=0]
----
SoftAssertions softly = new SoftAssertions();

// custom assertions
softly.check(() -> LotrAssertions.assertThat(frodo).hasName("Frodon"));
softly.check(() -> LotrAssertions.assertThat(frodo).hasName("Frodo"));

// standard assertions
softly.assertThat("foo").startsWith("bar");
// could be written with check like (but it's as elegant as the standard use):
// softly.check(() -> Assertions.assertThat("foo").startsWith("bar"));

// 2 errors: "foo" does not start with "bar" and frodo's name is not "Frodon"
assertThat(softly.errorsCollected()).hasSize(2);
----

[[assertj-core-3.13.0-containsExactlyInAnyOrderEntriesOf]]
[.release-note-item]#Add `containsExactlyInAnyOrderEntriesOf` to map assertions#

Verifies that the actual map contains only the given entries and nothing else, in any order.

This is the same assertion as `containsOnly(Map.Entry... entries)`, it simply handles the conversion of `Map.entrySet()` to array.


Example :

[source,java,indent=0]
----
Map<Ring, TolkienCharacter> ringBearers = newLinkedHashMap(entry(oneRing, frodo),
                                                           entry(nenya, galadriel),
                                                           entry(narya, gandalf));
// assertion will pass
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(narya, gandalf)));
// assertion will pass although actual and expected order differ
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(nenya, galadriel),
                                                                            entry(narya, gandalf),
                                                                            entry(oneRing, frodo)));
// assertion will fail as actual does not contain all entries of expected
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(oneRing, frodo)));
// assertion will fail as actual and expected have different sizes
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(narya, gandalf),
                                                                            entry(narya, gandalf)));
----

[[assertj-core-3.13.0-isCloseToUtcNow]]
[.release-note-item]#Add `isCloseToUtcNow` to `LocalDateTime` and `OffsetDateTime` assertions#

Verifies that the actual `LocalDateTime`/`OffsetDateTime` is close to the current date and time on the UTC timezone, according to the given offset. 

You can build the offset parameter using `Assertions.within(long, TemporalUnit)` or `Assertions.byLessThan(long, TemporalUnit)`.

If the difference is equal to the offset, the assertion succeeds. 

Example with `LocalDateTime`:

[source,java,indent=0]
----
LocalDateTime actual = LocalDateTime.now(Clock.systemUTC());

// assertion will pass if executed less than one second after actual was built
assertThat(actual).isCloseToUtcNow(byLessThan(1, ChronoUnit.SECONDS));

// assertion will fail
assertThat(actual.plusSeconds(2)).isCloseToUtcNow(within(1, ChronoUnit.SECONDS));
----

The same example works with `OffsetDateTime` by simply defining `actual` as: 
[source,java,indent=0]
----
OffsetDateTime actual = OffsetDateTime.now(Clock.systemUTC());
----

[[assertj-core-3.13.0-millisecond-and-timezone-parsing]]
[.release-note-item]#Add support for combined millisecond and timezone parsing#

Add `yyyy-MM-dd HH:mm:ss.SSSX` to the default date formats AssertJ supports in `Date` assertions that take a `String` parameter representating a `Date`. 

Here's an example of string following this format: `"2003-04-26T00:00:00.123+00:00"`.

Example:

[source,java,indent=0]
----
// GIVEN
SimpleDateFormat isoFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
isoFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
// WHEN
Date date = isoFormat.parse("2003-04-26T00:00:00.123");
// THEN
assertThat(date).isEqualTo("2003-04-26T00:00:00.123+00:00");
----

[[assertj-core-3.13.0-optional-support-in-recursive-comparison]]
[.release-note-item]#Add support for `Optional` in the new recursive comparison#

The recursive comparison added in 3.12.0 now compares `Optional` values recursively instead of comparing `Optional` with `equals`. This is consistent with comparing list elements by elements as an `Optional` can be seen as a list with at most one element. 

Example:

[source,java,indent=0]
----
// Song constructor parameters: song, author and coAuthor (optional)
Song song = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
Song expectedSong = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
// THEN
assertThat(song).usingRecursiveComparison()
                .isEqualTo(expectedSong);
----

where `Song` and `Author` don't override `equals`:

[source,java,indent=0]
----
class Song {

  Author author;
  Optional<Author> coAuthor;
  String song;

  Song(String song, Author author, Author coAuthor) {
    this.song = song;
    this.author = author;
    this.coAuthor = Optional.ofNullable(coAuthor);
  }

  // no equals!
}

class Author {

  String name;

  Author(String name) {
    this.name = name;
  }

  String getName() {
    return name;
  }

  // no equals!
}
----

If we fail the test \... 

[source,java,indent=0]
----
Song song = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Jimi Hendrix"));
Song expectedSong = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
// FAIL
assertThat(song).usingRecursiveComparison()
                .isEqualTo(expectedSong);
----

\... here's the error reported:

[source,text,indent=0]
----
Expecting:
  <Song [author=Mick Jagger, coAuthor=Optional[Jimi Hendrix], song=I Can't Get No Satisfaction]>
to be equal to:
  <Song [author=Mick Jagger, coAuthor=Optional[Keith Richards], song=I Can't Get No Satisfaction]>
when recursively comparing field by field, but found the following difference:

field/property 'coAuthor.value.name' differ:
- actual value   : "Jimi Hendrix"
- expected value : "Keith Richards"

The recursive comparison was performed with this configuration:
- overridden equals methods were used in the comparison
- these types were compared with the following comparators:
  - java.lang.Double -> DoubleComparator[precision=1.0E-15]
  - java.lang.Float -> FloatComparator[precision=1.0E-6]
- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).
----

[[assertj-core-3.13.0-ignore-order-in-recursive-comparison]]
[.release-note-item]#Allow ignoring collection order in the new recursive comparison#

The recursive comparison added in 3.12.0 can now ignore collection order in all fields in the object under test, this is handy when comparing list to set fields where only the content is relevant but not the order. 

Example:

[source,java,indent=0]
----
public class Person {
  String name;
  List<Person> friends = new ArrayList<>();
}

Person sherlock1 = new Person("Sherlock Holmes");
sherlock1.friends.add(new Person("Dr. John Watson"));
sherlock1.friends.add(new Person("Molly Hooper"));

Person sherlock2 = new Person("Sherlock Holmes");
sherlock2.friends.add(new Person("Molly Hooper"));
sherlock2.friends.add(new Person("Dr. John Watson"));

// assertion succeeds as all fields collection order is ignored in the comparison
assertThat(sherlock1).usingRecursiveComparison()
                     .ignoringCollectionOrder()
                     .isEqualTo(sherlock2);

// assertion fails as fields collection order is not ignored in the comparison
assertThat(sherlock1).usingRecursiveComparison()
                     .isEqualTo(sherlock2);
----

==== AssertJ Core 3.12.2 Release notes

The main issue fixed was to ignore static methods when finding property accessors (contributed by Andy Wilkinson) which could break some tests since bare name method introspection was introduced in 3.12.0.

`anySatisfy` for `Maps` was improved and does not continue evaluating elements once a match is found (contributed by Erhard Pointl).

==== AssertJ Core 3.12.1 Release notes

Fix a regression that included a bad module-info.class (thanks Jaro Kuruc) and other minor improvements.

==== AssertJ Core 3.12.0 Release notes

Release date : 2019-02-14

The main feature of this release is a beta version of the link:#assertj-core-recursive-comparison[new Recursive comparison API]!
It covers what `isEqualToComparingFieldByFieldRecursively` used but easier to use and with more capabilities.

It is a Beta version because we want to have feedback from the community to make it even better before freezing the API.
There are more capabilities to come in the next releases, stay tuned!

===== Contributors

Big thanks to all the contributors of this release:

Pascal Schumacher, Erhard Pointl, Vladimir Chernikov, Sandra Parsick, Martin Tarjanyi, Stephan Windmüller, Yaroslav Mitsynskiy, Thomas Traude, Georg Berky, Tomek Kaczanowski, Lukáš Křečan, Yoann Rodière, Filip Hrisafov, Steven Schlansker, Jeremy Landis, Jack Gough, Sebastian Kempken, Stefan Mandel, Alexandre de Champeaux, Arvid Heise, Jeff Walker, Dmitrii Priporov and Joshua Kitchen.

[[assertj-core-3.12.0-breaking-changes]]
===== Breaking changes

- Introduce first class `Iterator` assertions (Stephan Windmüller).

WARNING: This removes the previously supported "`Iterable`" assertions (like `containsOnly`), call http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIteratorAssert.html#toIterable--[`IteratorAssert#toIterable`] to access them again, ex:

[source,java,indent=0]
----
Iterator<String> bestBasketBallPlayers = getBestBasketBallPlayers();

assertThat(bestBasketBallPlayers).toIterable().contains("Jordan", "Magic", "Lebron");
----

- Add configurable support for bare-named property introspection. (Steven Schlansker)

AssertJ uses introspection in various places, one example is extracting properties as in `extracting("name")`. AssertJ is able to get values with getters like `getName()`, with this improvement it now can get property values with bare name method like `name()`.

WARNING: Bare-named property introspection is enabled by default and thus changes AssertJ behavior which can break some existing tests relying on introspection, this is especially true as AssertJ wrongly tries static methods (https://github.com/joel-costigliola/assertj-core/issues/1458 had been created to address that).

It is possible to avoid this probem by calling `Assertions.setExtractBareNamePropertyMethods(false);` before every impacted tests.

This is a bit tedious but an improvement is planned in the next release to provide a place to perform global configuration with the same mechanism allowing to link:#assertj-core-custom-representation-default-global-scope[register a custom representation].


===== New features

- New Recursive comparison API! (Beta version)
- Add `satisfiesAnyOf` base assertion. TODO document
- Add `isAbstract` to `Class` assertions. (Erhard Pointl)
- Add `hasValueCloseTo(percentage)` to `OptionalDouble` assertion. (Joshua Kitchen)
- Add `hasOnlyOneElementSatisfying(Consumer)` to `AtomicReferenceArray` assertions. (Vladimir Chernikov)
- Add `hasAllNullFieldsOrProperties` and `hasAllNullFieldsOrPropertiesExcept`. (Vladimir Chernikov)
- Add `hasSizeGreaterThan`, `hasSizeLessThanOrEqualTo`, `hasSizeGreaterThanOrEqualTo` and `hasSizeGreaterThan` to `CharSequence` and `String` assertions. (Sandra Parsick)
- Add `hasSizeGreaterThan`, `hasSizeLessThanOrEqualTo`, `hasSizeGreaterThanOrEqualTo`, `hasSizeGreaterThan` and `hasSizeBetween` to object and primitives array, `Iterable` and `Map`. (Martin Tarjanyi)
- Add `hasSizeBetween` to `CharSequence` and `String` assertions. (Martin Tarjanyi)
- Add `noneSatisfy(BiConsumer)` to `Map` assertions. (Erhard Pointl)
- Add `containsExactlyEntriesOf` assertion to check that a `Map` contains exactly all entries of another `Map`. (Filip Hrisafov)
- Add `containsOnlyKeys(Iterable keys)` to `Map` assertion. (Sebastian Kempken)
- Add `anySatifies(BiConsumer)` to `Map` assertion. (Stefan Mandel)
- Add `hasMessageNotContaining` to `Throwable` assertions. (Georg Berky and Sandra Parsick)
- Add `shouldHaveRootCause` to `Throwable` assertions to check the content of a root cause. (Jack Gough)
- Add `isEqualTo(String string, Objects... param)` to `String` assertion. (Dmitrii Priporov)
- Add `assertThatObject`/`thenObject` to force Object assertion. (Arvid Heise)
- Add JUnit5 to AssertJ assertions migration script for osx. (Tomek Kaczanowski)

===== Improvements

- Add stack trace of original exception to `catchThrowableOfType`. (Sam Smyth)
- `anySatisfy` and `noneSatisfy` now reports all failing elements. (Erhard Pointl)
- `ElementsShouldSatisfy` now uses the configured `Representation` to format objects.
- `ZipSatisfyError` now uses the configured `Representation` to format objects. (Jeff Walker)
- AssertJ `Double` and `Float` comparators now support `Infinity`. (Alexandre de Champeaux)
- Throw `AssertionFailedError` instead of `AssertionError` in some `String` assertions to allow IDEs to show `actual` vs `expected` visual differences. (Yaroslav Mitsynskiy)
- `Optional` `hasValue`/`contains` assertions throws `AssertionFailedError` to allow IDEs to show `actual` vs `expected` visual differences.
- Annotate `Assertions` and `Assumptions` classes with `@CheckReturnValue` and annotate methods to exclude from checking with `@CanIgnoreReturnValue`. (Pascal Schumacher)
- The error message of `allSatisfy(BiConsumer)` `Map` assertion now reports all failing entries instead of the first one. (Stefan Mandel)
- Add missing `@Since` annotations. (Erhard Pointl)
- Get rid of `Arguments` usage when possible in unit tests. (Erhard Pointl)
- Unit tests code cleanup and better use of JUnit 5. (Erhard Pointl, Pascal Schumacher and Jack Gough)
- Update to JUnit 5.4.0. (Erhard Pointl)
- Update to opentest4j to 1.1.1. (Erhard Pointl)
- Update to Byte Buddy 1.9.10. (Pascal Schumacher)
- Update Maven version to and the Maven wrapper. (Thomas Traude, Jeremy Landis)
- Do not proxy `useComparator` method in soft assertions. (Lukáš Křečan)
- Fix an NPE in `ObjectArrays#assertHasOnlyElementsOfType`. (Yoann Rodière)
- Deprecate `Extractor` in favor of `java.util.function.Function`. (Filip Hrisafov)

===== Fixed

- Use `@CanIgnoreReturnValue` on `Assertions` `fail*` methods to revert the effect of the default `@CheckReturnValue` annotation. (Erhard Pointl)
- Fix `ElementsShouldSatisfy` that failed to handle objects whose string representation contained `%`.
- Fix `ElementsShouldZipSatisfy` that failed to handle objects whose string representation contained `%`. (Arvid Heise)
