[[assertj-core-release-notes]]
=== Release Notes

NOTE: AssertJ Core would not exist without its contributors, you can find them all {assertj-core-repo}/graphs/contributors[directly on GitHub].

Latest release notes:

- link:#assertj-core-3-16-1-release-notes[AssertJ Core 3.16.1]
- link:#assertj-core-3-16-0-release-notes[AssertJ Core 3.16.0]
- link:#assertj-core-3-15-0-release-notes[AssertJ Core 3.15.0]
- link:#assertj-core-3-14-0-release-notes[AssertJ Core 3.14.0]
- link:#assertj-core-3-13-2-release-notes[AssertJ Core 3.13.2]
- link:#assertj-core-3-13-1-release-notes[AssertJ Core 3.13.1]
- link:#assertj-core-3-13-0-release-notes[AssertJ Core 3.13.0]
- link:#assertj-core-3-12-2-release-notes[AssertJ Core 3.12.2]
- link:#assertj-core-3-12-1-release-notes[AssertJ Core 3.12.1]
- link:#assertj-core-3-12-0-release-notes[AssertJ Core 3.12.0]

Older release notes can be found in the old site: https://joel-costigliola.github.io/assertj/assertj-core-news.html, this is important to be aware of breaking changes if you are migrating from an old version.

[[assertj-core-3-16-1-release-notes]]
==== AssertJ Core 3.16.1

Release date : 2020-05-09

[[assertj-core-3.16.1-contributors]]
[.release-note-category]#icon:user[] Contributors#

Thanks to Erhard Pointl and Eddú Meléndez Gonzales for their contributions.

[[assertj-core-3.16.1-fixed]]
[.release-note-category]#icon:wrench[] Fixed#

- Fix NPE in recursive comparison when checking local or anonymous classes. (#1868)
- Fix `assertThat(Duration actual)` javadoc. (Eddú Meléndez Gonzales)


[[assertj-core-3-16-0-release-notes]]
==== AssertJ Core 3.16.0

Release date : 2020-05-05

[[assertj-core-3.16.0-contributors]]
[.release-note-category]#icon:user[] Contributors#

Thanks to all the contributors of this release: Erhard Pointl, Stefano Cordio, Pascal Schumacher, Wim Deblauwe, Fabien Duminy, Piotrek Żygieło, Indrek Priks, Jakzi666, Daniel Avila, Harisha Talanki, Grzegorz Piwowarek, Andreas Mager, Sunt-ing, ebundy, Stefan Birkner, WuYff, Cal027, Yubin Hu and Fr Jeremy Krieg.

[[assertj-core-3.16.0-breaking-changes]]
[.release-note-category]#icon:exclamation-triangle[] Breaking changes#

* `AbstractSoftAssertions` is now `abstract`
* The following base soft assertions classes were changed to interfaces (with default methods) and renamed:
** `AbstractBDDSoftAssertions` was renamed to `BDDSoftAssertionsProvider`
** `AbstractStandardSoftAssertions` was renamed to `StandardSoftAssertionsProvider`
** `Java6AbstractBDDSoftAssertions` was renamed to `Java6BDDSoftAssertionsProvider`
** `Java6AbstractStandardSoftAssertions` was renamed to `Java6StandardSoftAssertionsProvider`
* Move ThrowingCallable from `AbstractSoftAssertions` to  `SoftAssertionsProvider`.

[[assertj-core-3.16.0-new-features]]
[.release-note-category]#icon:plus-circle[] New features#

- Allow link:#assertj-core-soft-assertions-combining[combining soft assertions entry points]. (Fr Jeremy Krieg) 
- Support link:#assertj-core-junit5-soft-assertions-custom-injection[injecting custom soft assertions in JUnit 5 `SoftAssertionExtension`]. (Fr Jeremy Krieg) 
- Add assertions on the link:#assertj-core-throwable-cause-and-root-cause-assertions[cause and root cause exception message]. (Wim Deblauwe)
- Recursive comparison learned to link:#assertj-core-recursive-comparison-ignoring-all-expected-null-fields[ignore null fields from the expected object].
- Recursive comparison learned to link:#assertj-core-recursive-comparison-ignoring-all-actual-empty-optional-fields[ ignore all actual empty optional fields].
- Add assertion to link:#assertj-core-3.16.0-string-ignoring-punctuation[compare string ignoring punctuation and normalizing whitespaces]. (Harisha Talanki) 
- Add link:#assertj-core-3.16.0-string-isBase64[`isBase64`] to `String` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.16.0-string-decodedAsBase64[`decodedAsBase64`] to `String` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.16.0-byte-array-encodedAsBase64[`encodedAsBase64`] to `byte[]` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.16.0-LongAdder[`java.util.concurrent.atomic.LongAdder`] assertions. (Grzegorz Piwowarek)
- Add link:#assertj-core-3.16.0-byte-array-asHexString[`asHexString`] to `byte[]` assertions. (Andreas Mager) 
- Add link:#assertj-core-3.16.0-url-isEqualToWithSortedQueryParameters[`isEqualToWithSortedQueryParameters`] to `URL` assertions. (Sunt-ing) 
- Add link:#assertj-core-3.16.0-isDirectoryRecursivelyContaining[`isDirectoryRecursivelyContaining`] to `File`/`Path` assertions. (ebundy) 
- Add link:#assertj-core-3.16.0-hasBinaryContent[`hasBinaryContent`] to `InputStream` assertions. (Stefan Birkner) 
- Add link:#assertj-core-3.16.0-containsOnlyOnceElementsOf[`containsOnlyOnceElementsOf`] to `Iterable`/`Object array`/`AtomicReferenceArray` assertions. (Cal027) 

[[assertj-core-3.16.0-improvements]]
[.release-note-category]#icon:arrow-circle-up[] Improvements#

- `ByteArrayAssert.containsExactly(byte...)` error message now mentions not found and unexpected elements. (Indrek Priks)
- In "should be package private" class assertion, the error message now explicitly mentions package-private instead of a blank value.  
- Use primitive comparison in `Float` and `Double` `isNotEqualTo` when compared to primitive float/double values.
- link:#assertj-core-3.16.0-disambiguate-date-representation[Disambiguate colliding date/time representation].
- Support up to four arguments for `satisfiesAnyOf()`. (Jakzi666)
- Clarify the error message when comparing float/double NaN with ==.
- Use a more descriptive element's name in ShouldContain/ShouldContainOnly error message. (WuYff)
- Add short array assertions taking `int...`. (Daniel Avila)
- Use AssertJ site theme for javadoc.
- Improve converting JUnit/JUnit5 assertions to AssertJ. (Yubin Hu)
- Move core `extracting` features from `AbstractObjectAssert` to `AbstractAssert`, making them available for custom assertions. (Stefano Cordio)
- Improve line number accuracy in soft assertion error messages. (Stefano Cordio)
- Internal: introduce EqualsVerifier for internal tests. (Stefano Cordio)
- Internal: optimize Charset finding in tests. (Fabien Duminy)
- Internal: clean up unused imports (Erhard Pointl, Piotrek Żygieło, Stefano Cordio, Pascal Schumacher)
- Internal: use static imports. (Piotrek Żygieło)
- Internal: remove unnecessary type parameters from extractors. (Stefano Cordio)
- Internal: access assertion info directly in `AtomicLongAssert`/`AtomicIntegerAssert`. (Grzegorz Piwowarek)
- Re-enable Sonar reports. (Stefano Cordio)
- Update ByteBuddy to version 1.10.10.
- Update JUnit Jupiter to version 5.6.2 (still optional).

[[assertj-core-3.16.0-fixed]]
[.release-note-category]#icon:wrench[] Fixed#

- Fix infinite recursion in recursive comparison when dealing with Path. (#1855)
- Fix recursive comparison way of tracking already visited objects. (#1854)
- Fix typos (Wim Deblauwe, Stefano Cordio)

[[assertj-core-3.16.0-deprecated]]
[.release-note-category]#icon:ban[] Deprecated#

- Deprecate `areEqual()` and `areEqualArrays()` in `org.assertj.core.util.Objects`.
- Deprecate `temporaryFolder()` in `org.assertj.core.util.Files`. (Sunt-ing) 

[[assertj-core-3.16.0-LongAdder]]
[.release-note-item]#Add `java.util.concurrent.atomic.LongAdder` assertions#

The following `java.util.concurrent.atomic.LongAdder` assertions are available:

- `hasValue(long expected)`, which verifies that the actual LongAdder sum has the given value.
- `doesNotHaveValue(long unexpected)`, which verifies that the actual LongAdder sum has not the given value.
- All the assertions provided by `NumberAssert`, using the LongAdder sum as actual value.
- All the assertions provided by `ComparableAssert`, using the LongAdder sum as actual value.

[[assertj-core-3.16.0-string-ignoring-punctuation]]
[.release-note-item]#Comparison ignoring punctuation and normalizing whitespaces#

Verifies that the actual `CharSequence` is equal to the given one, after the punctuation of both strings have been normalized.

To be exact, the following rules are applied:

* All punctuation of actual and expected strings are ignored and whitespaces are normalized
* Punctuation is any of the following characters: `!"#$%&'()*+,-./:;=<>?@[\]^_{|}~\`` 

Examples:
[source,java]
----
// assertions succeed:
assertThat("Game'of'Thrones").isEqualToNormalizingPunctuationAndWhitespace("GameofThrones")
assertThat("Game of Throne's").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat(":Game of Thrones:").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat(":Game-of-Thrones:").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat("Game of Thrones?").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat("Game of Thrones!!!").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat("Game of  {{(!)}}    Thrones!!!").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones")
assertThat("{(Game)-(of)-(Thrones)!!!}").isEqualToNormalizingPunctuationAndWhitespace("GameofThrones");

// assertions fail:
assertThat("Game-of-Thrones").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones");
assertThat("{Game:of:Thrones}").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones");
assertThat("{(Game)-(of)-(Thrones)!!!}").isEqualToNormalizingPunctuationAndWhitespace("Game of Thrones");
----

[[assertj-core-3.16.0-string-isBase64]]
[.release-note-item]#isBase64#

Verifies that the given `String` is a valid Base64 encoded string. (this is not available for `CharSequence`).

Examples:
[source,java]
----
// assertions succeeds
assertThat("QXNzZXJ0Sg==").isBase64();

// assertion succeeds even without padding as it is optional by specification
assertThat("QXNzZXJ0Sg").isBase64();

// assertion fails as it has invalid Base64 characters
assertThat("inv@lid").isBase64();
----

[[assertj-core-3.16.0-string-decodedAsBase64]]
[.release-note-item]#decodedAsBase64#

Decodes the actual `String` value as a Base64 encoded string, the decoded bytes becoming the new array under test.

Examples:
[source,java]
----
// assertions succeeds
assertThat("QXNzZXJ0Sg==").decodedAsBase64()
                          .containsExactly("AssertJ".getBytes());

// assertion succeeds even without padding as it is optional by specification
assertThat("QXNzZXJ0Sg").decodedAsBase64()
                        .containsExactly("AssertJ".getBytes());

// assertion fails as it has invalid Base64 characters
assertThat("inv@lid").decodedAsBase64();
----


[[assertj-core-3.16.0-byte-array-asHexString]]
[.release-note-item]#Add `asHexString` to `byte[]` assertions#

Converts the actual byte array under test to an hexadecimal String and returns assertions for the computed String allowing String specific assertions from this call. +
The hexadecimal `String` representation is in upper case.

Example :
[source,java]
----
byte[] bytes = new byte[] { -1, 0, 1 };

// assertion will pass
assertThat(bytes).asHexString()
                 .startsWith("FF")
                 .isEqualTo("FF0001");
----

[[assertj-core-3.16.0-url-isEqualToWithSortedQueryParameters]]
[.release-note-item]#Add `isEqualToWithSortedQueryParameters`] to `URL` assertions#

Verifies that the actual URL is equivalent to the given one after their parameters are sorted. 

Example :
[source,java]
----
URL url = new URL("http://example.com?a=b&c=d");

// these assertions succeed ...
assertThat(url).isEqualToWithSortedQueryParameters(new URL("http://example.com?c=d&a=b"))
               .isEqualToWithSortedQueryParameters(new URL("http://example.com?a=b&c=d"));

// ... but this one fails as parameters do not match.
assertThat(url).isEqualToWithSortedQueryParameters(new URL("http://example.com?a=b&c=e"));

//... and this one fails as domains are different.
assertThat(url).isEqualToWithSortedQueryParameters(new URL("http://example2.com?amp;a=b&c=d")); 
----


[[assertj-core-3.16.0-isDirectoryRecursivelyContaining]]
[.release-note-item]#Add `isDirectoryRecursivelyContaining` to `File`/`Path` assertions#

Verify that the actual `File`/`Path` directory or any of its subdirectories (recursively) contains at least one file matching the given criteria expressed as:

* a `String` interpreted as a path matcher (as per `FileSystem.getPathMatcher(String)`)
* a `String` interpreted as a path matcher (as per `FileSystem.getPathMatcher(String)`)

These assertions are similart to `isDirectoryContaining` but recursively go into subdirectories.

Note that the actual `File`/`Path` must exist and be a directory.

Examples with files given the following directory structure:

[source,text]
----
 root
 |—— foo
 |    |—— foobar
 |         |—— foo-file-1.ext
 |—— foo-file-2.ext
----

Examples with syntax patterns: 
[source,java]
----
File root = new File("root");

// The following assertions succeed:
assertThat(root).isDirectoryRecursivelyContaining("glob:**foo")
                .isDirectoryRecursivelyContaining("glob:**ooba*")
                .isDirectoryRecursivelyContaining("glob:**file-1.ext")
                .isDirectoryRecursivelyContaining("regex:.*file-2.*")
                .isDirectoryRecursivelyContaining("glob:**.{ext,dummy}");

// The following assertions fail:
assertThat(root).isDirectoryRecursivelyContaining("glob:**fooba");
assertThat(root).isDirectoryRecursivelyContaining("glob:**.bin");
assertThat(root).isDirectoryRecursivelyContaining("glob:**.{java,class}");
----

Examples with predicates: 
[source,java]
----
File root = new File("root");

// The following assertions succeed:
assertThat(root).isDirectoryRecursivelyContaining(file -> file.getName().startsWith("foo-file-1"))
                .isDirectoryRecursivelyContaining(file -> file.getName().endsWith("file-2.ext"))
                .isDirectoryRecursivelyContaining(file -> file.getName().equals("foo"))
                .isDirectoryRecursivelyContaining(file -> file.getParentFile().getName().equals("foo"))

// The following assertions fail:
assertThat(root).isDirectoryRecursivelyContaining(file -> file.getName().equals("foo-file-1"))
assertThat(root).isDirectoryRecursivelyContaining(file -> file.getName().equals("foo/foobar")); 
----

[[assertj-core-3.16.0-hasBinaryContent]]
[.release-note-item]#Add `hasBinaryContent` to `InputStream` assertions#

Verifies that the binary content of the actual InputStream is exactly equal to the given one.

Example: the following failing assertion ... 
[source,java,indent=0]
----
InputStream inputStream = new ByteArrayInputStream(new byte[] {1, 2});

// assertion will pass
assertThat(inputStream).hasContent(new byte[] {1, 2});

// assertions will fail
assertThat(inputStream).hasBinaryContent(new byte[] { });
assertThat(inputStream).hasBinaryContent(new byte[] {0, 0});
----


[[assertj-core-3.16.0-containsOnlyOnceElementsOf]]
[.release-note-item]#Add `containsOnlyOnceElementsOf` to `Iterable`/`Object array`/`AtomicReferenceArray` assertions#

Verifies that the actual group contains the elements of the given iterable only once (same semantic as `containsOnlyOnce(Object...)`). 

Examples:
[source,java,indent=0]
----
// assertions will pass
assertThat(list("winter", "is", "coming")).containsOnlyOnceElementsOf(list("winter"))
                                          .containsOnlyOnceElementsOf(list("coming", "winter"));

// assertions will fail
assertThat(list("winter", "is", "coming")).containsOnlyOnceElementsOf(list("Lannister"));
assertThat(list("Arya", "Stark", "daughter", "of", "Ned", "Stark")).containsOnlyOnceElementsOf(list("Stark"));
assertThat(list("Arya", "Stark", "daughter", "of", "Ned", "Stark")).containsOnlyOnceElementsOf(list("Stark", "Lannister", "Arya"));
----

[[assertj-core-3.16.0-disambiguate-date-representation]]
[.release-note-item]#Disambiguate colliding date/time representation#

Different date/time types can be represented the same way (`LocalDateTime` and `Date` for example) which makes it difficult to understand error messages as they don't show any difference between actual and expected values. AssertJ now adds the date/time type name for types whose representation may collide.

Example: the following failing assertion ... 
[source,java,indent=0]
----
Date now = new Date();
Object localDateTime = LocalDateTime.ofInstant(now.toInstant(), ZoneId.systemDefault());

assertThat(List.of(localDateTime)).containsExactly(now);
----

\... fails with this error:

[source,indent=0]
----
Expecting:
  <[2020-03-19T22:32:42.875 (java.time.LocalDateTime)]>
to contain exactly (and in same order):
  <[2020-03-19T22:32:42.875 (java.util.Date)]>
but some elements were not found:
  <[2020-03-19T22:32:42.875 (java.util.Date)]>
and others were not expected:
  <[2020-03-19T22:32:42.875 (java.time.LocalDateTime)]>
----

Before that the error would have been confusing:
[source,indent=0]
----
Expecting:
  <[2020-03-19T22:32:42.875]>
to contain exactly (and in same order):
  <[2020-03-19T22:32:42.875]>
but some elements were not found:
  <[2020-03-19T22:32:42.875]>
and others were not expected:
  <[2020-03-19T22:32:42.875]>
----

[[assertj-core-3-15-0-release-notes]]
==== AssertJ Core 3.15.0

Release date : 2020-01-28

The recursive comparison API has been promoted and is not a beta API anymore.

[[assertj-core-3.15.0-contributors]]
[.release-note-category]#icon:user[] Contributors#

Thanks to all the contributors of this release: Erhard Pointl, Stefano Cordio, Pascal Schumacher, BJ Hargrave, Raymond Augé, Thomas Weißschuh, Maciej Wajcht, Hayden Meloche, Filip Hrisafov, Jayati Goyal, Gyumin Kim, Clemens Grabmann, Roman Leventov, Fr Jeremy Krieg, Benoit Dupont, Nikolaos Georgiou, Christian Stein, Jeremy Landis, Graham Dennis, Fabien Duminy, Tommy Situ and Vincent Ricard.

Shout out to Vincent Ricard for the various tests refactoring, that was quite a lot of work!

[[assertj-core-3.15.0-breaking-changes]]
[.release-note-category]#icon:exclamation-triangle[] Breaking changes#

* Compares `OffsetDateTime`, `ZonedDateTime` and `LocalDateTime` using their `timeLineOrder()` comparator as default.
** For `OffsetDateTime` the `timeLineOrder` comparator only compares the underlying instant and ignores different timezones / offsets / chronologies.
** For `ZonedDateTime` the `timeLineOrder` comparator ignores the chronology, this is equivalent to comparing the epoch-second and nano-of-second.
** For `LocalDateTime` the `timeLineOrder` comparator ignores the chronology, this is equivalent to comparing the epoch-day and nano-of-day and allows dates in different calendar systems to be compared based on the position of the date-time on the local time-line.
* A single `Path` parameter for `containsOnlyKeys` in `Map` assertions is treated as a single key rather than an `Iterable` of keys.
* Fix floating point comparison behavior in `DoubleAssert` and `FloatAssert`, which now follows primitive comparison (`==`, `&#x2264;`, `&#x2265;`) when the expected value is primitive but uses the corresponding `equals` semantic when the expected value is a wrapper.
* Fix a double decoding issue in `UriAssert`, which now uses the raw query to evaluate URI parameters avoiding the mishandling of escaped `&` and `=`. (Graham Dennis)
* Remove duplication for `Descriptable` implementations using default methods. This is a binary incompatible change. (Fr Jeremy Krieg)

[[assertj-core-3.15.0-new-features]]
[.release-note-category]#icon:plus-circle[] New features#

- Add link:#assertj-core-3.15.0-Duration[`java.time.Duration`] assertions. (Filip Hrisafov)
- Add link:#assertj-core-3.15.0-isPackagePrivate[`isPackagePrivate`] to `Class` assertions. (Hayden Meloche)
- Add link:#assertj-core-3.15.0-hasSameBinaryContentAs[`hasSameBinaryContentAs`] to `File`/`Path` assertions. (Nikolaos Georgiou)
- Add link:#assertj-core-3.15.0-succeedsWithin[`succeedsWithin`] to `CompletableFuture` assertions.
- Add link:#assertj-core-3.15.0-hasSuperclass[`hasSuperclass`] to `Class` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.15.0-hasNoSuperclass[`hasNoSuperclass`] to `Class` assertions. (Stefano Cordio)
- Make the link:#assertj-core-3.15.0-recursive-comparison[recursive comparison API] directly available to `Iterable`, `Map`, `Optional` and array assertions.
- Allow to <<assertj-core-assertions-guide.adoc#assertj-core-recursive-comparison-ignoring-fields,ignore fields by type>> in the recursive comparison. (Tommy Situ)

[[assertj-core-3.15.0-improvements]]
[.release-note-category]#icon:arrow-circle-up[] Improvements#

- Show explicitly if a class is `package-private` in `ClassModifierShouldBe` error message.
- Various module descriptor improvements: (Christian Stein and Stefano Cordio)
** Remove JSR-305 due to issues with java 9 modules. (Stefano Cordio)
** Remove .core.internal from exported packages. (Stefano Cordio)
- Update ByteBuddy to version 1.10.6.
- Update JUnit to version 4.13 (still optional).
- Update JUnit Jupiter to version 5.6.0 (still optional).
- Make OSGi import of jdk.* packages optional. (BJ Hargrave)
- Use bnd 5.0.0 to a) use -noclassforname instruction b) generate most up to date OSGi metadata c) add verification that additional package imports never sneak in. (Raymond Augé)
- Get rid of unnecessary extra arguments in `String.format`. (Erhard Pointl)
- Unify `actual` and `expected` formatting in `hasToString()` error which is now `AssertionFailedError` to allow visual comparison. (Thomas Weißschuh)
- Add missing BDD assertions for exception handling (`thenExceptionOfType`, `thenNullPointerException`, `thenIllegalArgumentException`, `thenIOException` and `thenIllegalStateException`). (Maciej Wajcht)
- Rewrite `LocalDateAssert`, `LocalDateTimeAssert`, `LocalTimeAssert` and `OffsetDateTimeAssert` tests to be more compliant with the contribution guidelines. (Clemens Grabmann)
- Remove IntelliJ IDEA configuration file for Language Injection as the rules are part of the built-in configuration since IntelliJ IDEA
2019.3. (Stefano Cordio)
- Improve performance of `containsOnly()` on very large collections. (Roman Leventov)
- Configure GitHub Actions for Windows and MacOS. (Filip Hrisafov)
- Use parameterized tests for `assertHasParameter()` in URI assertions. (Stefano Cordio)
- Show the stack trace of the Throwable under test when `hasMessageContaining` and `hasMessageContainingAll` fails. (Benoit Dupont)
- Bump maven wrapper to 0.5.6. (Jeremy Landis)
- Improve the representation of failed `CompletableFuture` showing the exception that caused the failure.
- Use `Objects.requireNonNull` instead of manually creating NullPointerExceptions. (Pascal Schumacher)
- Remove unused methods. (Fabien Duminy)
- Replace `try`/`catch` exception assertion with `catchThrowable` pattern. (Vincent Ricard)
- Remove `failBecauseExpectedAssertionErrorWasNotThrown`. (Vincent Ricard)
- Replace the `TestFailures` helper class by the `catchThrowable` pattern. (Vincent Ricard)
- Update license year to 2020.

[[assertj-core-3.15.0-fixed]]
[.release-note-category]#icon:wrench[] Fixed#

- Fix grammatical errors in README.md (Jayati Goyal)
- Fix `allOf(Iterable)` and `anyOf(Iterable)` that no longer tracked descriptions when built with an `Iterable<Condition>`.
- Fix typos in javadoc and comments. (Erhard Pointl)
- Add `abstract` modifier for `Java6AbstractStandardSoftAssertions`. (Stefano Cordio)
- Fix typo in javadoc. (Gyumin Kim)
- Fix how `Enum` are compared in recursive comparison which now compares them by value.
- Fix tests failing only on Windows. (Fr Jeremy Krieg)
- Refactoring: remove useless null check. (Pascal Schumacher)
- Fix use `equals` to compare enum names in recursive comparison.
- Fix how `containsOnlyKeys` in `MapAssert` considers a single `Path` parameter, which is now treated as a single key rather than an `Iterable` of keys. (Stefano Cordio)
- Fix the recursive comparison that used to register fields of objects with overridden `equals` when it should not have to.
- Fix property and field extraction with `Map` input, which now tries at first to extract a property or a field by name and only in case of failure uses the input name as a `Map` key. (Stefano Cordio)

[[assertj-core-3.15.0-deprecated]]
[.release-note-category]#icon:ban[] Deprecated#

- Deprecate `hasSameContentAs` in favor of `hasSameTextualContentAs` and the new `hasSameBinaryContentAs`.
- Deprecate `Preconditions#checkNotNull(Object)` in favor of `Objects.requireNonNull(Object)`.
- Deprecate `Preconditions#checkNotNull(Object, String)` in favor of `Objects.requireNonNull(Object, String)`.

[[assertj-core-3.15.0-Duration]]
[.release-note-item]#Add `java.time.Duration` assertions#

The following `java.time.Duration` assertions are available:

- `hasDays​(long otherDays)`: Verifies that the actual Duration has the given days.
- `hasHours​(long otherHours)`: Verifies that the actual Duration has the given hours.
- `hasMillis​(long otherMillis)`: Verifies that the actual Duration has the given millis.
- `hasMinutes​(long otherMinutes)`: Verifies that the actual Duration has the given minutes.
- `hasNanos​(long otherNanos)`: Verifies that the actual Duration has the given nanos.
- `hasSeconds​(long otherSeconds)`: Verifies that the actual Duration has the given seconds.
- `isNegative()`: Verifies that the actual Duration is negative (i.e. < `Duration.ZERO`)
- `isPositive()`: Verifies that the actual Duration is positive (i.e. > `Duration.ZERO`)
- `isZero()`: Verifies that the actual Duration is `Duration.ZERO`.

Examples:
[source,java,indent=0]
----
assertThat(Duration.ofDays(5)).hasDays(5);
assertThat(Duration.ofHours(15)).hasHours(15);

assertThat(Duration.ofMinutes(65)).hasMinutes(65);
assertThat(Duration.ofSeconds(250)).hasSeconds(250);

assertThat(Duration.ofMillis(250)).hasMillis(250);
assertThat(Duration.ofNanos(145)).hasNanos(145);

assertThat(Duration.ofHours(5)).isPositive();
assertThat(Duration.ofMinutes(-15)).isNegative();
assertThat(Duration.ZERO).isZero();
----

[[assertj-core-3.15.0-isPackagePrivate]]
[.release-note-item]#Add `isPackagePrivate` to `Class` assertions#

Verifies that the actual `Class` is package-private (i.e. has no modifier).

Example:
[source,java,indent=0]
----
class MyClass {}

// this assertion succeeds:
assertThat(MyClass.class).isPackagePrivate();

// this assertion fails:
assertThat(String.class).isPackagePrivate();
----

[[assertj-core-3.15.0-hasSameBinaryContentAs]]
[.release-note-item]#Add `hasSameBinaryContentAs` to `File`/`Path` assertions#

Verifies that the content of the actual file/path is equal to the content of the given one, the comparison is done at the binary level.

Example with `Path` (works the same with `File`):
[source,java,indent=0]
----
// The first two paths have the same content, the third does not
Path aPath = Files.write(Paths.get("a-file.bin"), new byte[] { 42 });
Path bPath = Files.write(Paths.get("b-file.bin"), new byte[] { 42 });
Path cPath = Files.write(Paths.get("c-file.bin"), new byte[] { 24 });

// The following assertion succeeds:
assertThat(aPath).hasSameBinaryContentAs(bPath);

// The following assertion fails:
assertThat(aPath).hasSameBinaryContent(cPath);
----

[[assertj-core-3.15.0-succeedsWithin]]
[.release-note-item]#Add `succeedsWithin` to `CompletableFuture` assertions#

Waits if necessary for at most the given time for this future to complete, and then returns its result for futher assertions.
If the future's result is not available for any reason an assertion error is thrown.

The time to wait for can be expressed with a `Duration` or a `TimeUnit`.

To get assertions for the future result's type use `succeedsWithin` that takes an additional `InstanceOfAssertFactory` parameter. 

Examples:
[source,java,indent=0]
----
CompletableFuture<String> future = CompletableFuture.completedFuture("ook!");

// assertion expressed with TimeUnit
assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS)
                  .isEqualTo("ook!");

// same assertion with Duration
assertThat(future).succeedsWithin(Duration.ofMillis(100))
                  .isEqualTo("ook!");

// STRING is a static import of InstanceOfAssertFactories.STRING
// we can then chain String assertions
assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS, STRING)
                  .startsWith("oo");                   
----

[[assertj-core-3.15.0-hasSuperclass]]
[.release-note-item]#Add `hasSuperclass` to `Class` assertions#

Verifies that the actual `Class` has the given superclass.

Example:
[source,java,indent=0]
----
// this assertion succeeds:
assertThat(Integer.class).hasSuperclass(Number.class);

// this assertion succeeds as superclass for array classes is Object:
assertThat(Integer[].class).hasSuperclass(Object.class);

// this assertion fails:
assertThat(String.class).hasSuperclass(Number.class);

// this assertion fails as only direct superclass matches:
assertThat(String.class).hasSuperclass(Object.class);

// this assertion fails as interfaces are not superclasses:
assertThat(String.class).hasSuperclass(Comparable.class);
----

[[assertj-core-3.15.0-hasNoSuperclass]]
[.release-note-item]#Add `hasNoSuperclass` to `Class` assertions#

Verifies that the actual `Class` has no superclass.

Example:
[source,java,indent=0]
----
// this assertion succeeds as interfaces have no superclass:
assertThat(Cloneable.class).hasNoSuperclass();

// this assertion succeeds as primitive types have no superclass:
assertThat(Integer.TYPE).hasNoSuperclass();

// this assertion succeeds as void type has no superclass:
assertThat(Void.TYPE).hasNoSuperclass();

// this assertion fails as Integer has Number as superclass:
assertThat(Integer.class).hasNoSuperclass();
----

[[assertj-core-3.15.0-recursive-comparison]]
[.release-note-item]#Make recursive comparison API directly available to `Iterable`, `Map`, `Optional` and array assertions#

Expose the recursive comparison for `Iterable`, `Map`, `Optional` and array assertions without having to cast them to `Object` as previously (because the API was only available for `Object` assertions).

At the moment, the only assertion available after in the recursive comparison is `isEqualTo`, there are plans to provide type specific recursive assertions in future (ex: iterable `contains`).

The recursive comparison API lets you finely control how to compare instances, please consult the <<assertj-core-assertions-guide.adoc#assertj-core-recursive-comparison,documentation>>  for a detailed guide. 

For the following examples we use `Person` and `Doctor`, two classes with the same structure:
[source,java,indent=0]
----
public class Person {
  String name;
  boolean hasPhd;
}

public class Doctor {
 String name;
 boolean hasPhd;
}

Doctor drSheldon = new Doctor("Sheldon Cooper", true);
Doctor drLeonard = new Doctor("Leonard Hofstadter", true);
Doctor drRaj = new Doctor("Raj Koothrappali", true);

Person sheldon = new Person("Sheldon Cooper", true);
Person leonard = new Person("Leonard Hofstadter", true);
Person raj = new Person("Raj Koothrappali", true);
----

`Iterable` example:
[source,java,indent=0]
----

List<Doctor> doctors = list(drSheldon, drLeonard, drRaj);
List<Person> people = list(sheldon, leonard, raj);

// assertion succeeds as both lists contains equivalent items in order.
assertThat(doctors).usingRecursiveComparison()
                   .isEqualTo(people);
----

Array example:
[source,java,indent=0]
----

Doctor[] doctors = { drSheldon, drLeonard, drRaj };
Person[] people = { sheldon, leonard, raj };

// assertion succeeds as both lists contains equivalent items in order.
assertThat(doctors).usingRecursiveComparison()
                   .isEqualTo(people);
----

`Map` example:
[source,java,indent=0]
----

Map<String, Doctor> doctors = mapOf(entry(drSheldon.name, drSheldon),
                                    entry(drLeonard.name, drLeonard),
                                    entry(drRaj.name, drRaj));

Map<String, Person> people = mapOf(entry(sheldon.name, sheldon),
                                   entry(leonard.name, leonard),
                                   entry(raj.name, raj));

// assertion succeeds as both maps contains equivalent items.
assertThat(doctors).usingRecursiveComparison()
                   .isEqualTo(people);
----

`Optional` example:
[source,java,indent=0]
----
Optional<Doctor> doctor = Optional.of(drSheldon);
Optional<Person> person = Optional.of(sheldon);

// assertion succeeds as both maps contains equivalent items.
assertThat(doctor).usingRecursiveComparison()
                  .isEqualTo(person);
----


// 3.14.0 release notes

[[assertj-core-3-14-0-release-notes]]
==== AssertJ Core 3.14.0

Release date : 2019-10-27

[[assertj-core-3.14.0-contributors]]
[.release-note-category]#icon:user[] Contributors#

Thanks to all the contributors of this release: Erhard Pointl, Stefano Cordio, Jonas Berlin, Thami Inaflas, Geoffrey Arthaud, Carter Kozak, Kevin Toublanc, Krishna Chaithanya Ganta, sowmiyamuthuraman, Edgar Asatryan, Oleksii Khomchenko, Gonzalo Müller Bravo, Stephen O'Rourke, Sven Johansson, William Bakker, Rob Spieldenner, Raymond Pressly, Michael Keppler and Clemens Grabmann.

[[assertj-core-3.14.0-breaking-changes]]
[.release-note-category]#icon:exclamation-triangle[] Breaking changes#

- Stop throwing an `IllegalArgumentException` when `isIn` and `isNotIn` are given an empty group of values.

[[assertj-core-3.14.0-new-features]]
[.release-note-category]#icon:plus-circle[] New features#

- Add link:#assertj-core-3.14.0-bdd-assumptions[BDD assumptions]. (Gonzalo Müller Bravo)
- Add link:#assertj-core-3.14.0-spliterator-assertions[`Spliterator` assertions]. (William Bakker)
- Add link:#assertj-core-3.14.0-isAtSameInstantAs[`isAtSameInstantAs`] to `OffsetDateTime` assertions. (Raymond Pressly)
- Add link:#assertj-core-3.14.0-assertAlso[`assertAlso`] `SoftAssertions` method to allow combining different soft assertions instances. (Kevin Toublanc)
- Add link:#assertj-core-3.14.0-isEmpty-isNotEmpty-file-assertions[`isEmpty` and `isNotEmpty`] file assertions. (Stephen O'Rourke)
- Add link:#assertj-core-3.14.0-hasSize[`hasSize(long expectedSizeInBytes)`] to `File` assertions. (Krishna Chaithanya Ganta)
- Avoid BDDMockito/BDDAssertions `then(object)` clash with link:#assertj-core-3.14.0-bdd-assertions-and[`and.then(object)`] method. (Gonzalo Müller Bravo)
- Add link:#assertj-core-3.14.0-hasRootCauseMessage[`hasRootCauseMessage`] to `Throwable` assertions. (Oleksii Khomchenko)
- Add syntax sugar link:#assertj-core-3.14.0-as-instance-of-assert-factory[`as(InstanceOfAssertFactory)`] to `Assertions` and `WithAssertions` for improved readability. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-extracting-string[`extracting(String, InstanceOfAssertFactory)`] to `Object` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-extracting-function[`extracting(Function, InstanceOfAssertFactory)`] to `Object` assertions. (Stefano Cordio)
- Add `extractingByKey(KEY)` and `extractingByKeys(KEY...)` to `Map` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-map-extracting-by-key[`extractingByKey(KEY, InstanceOfAssertFactory)`] to `Map` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-optional-get[`get(InstanceOfAssertFactory)`] to `Optional` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-iterable-first[`first(InstanceOfAssertFactory)`] to `Iterable` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-iterable-last[`last(InstanceOfAssertFactory)`] to `Iterable` assertions. (Stefano Cordio)
- Add link:#assertj-core-3.14.0-iterable-element[`element(int, InstanceOfAssertFactory)`] to `Iterable` assertions. (Stefano Cordio)
- Add IntelliJ IDEA configuration file for Language Injection to add syntax highlighting on AssertJ methods with regexp parameters. (Jonas Berlin)
- Add `String.format` support for link:#assertj-core-3.14.0-throwable-assertions-string-format[expected message] in `hasMessageStartingWith`, `hasMessageContaining`, `hasMessageEndingWith` and `hasStackTraceContaining` assertions.  (Krishna Chaithanya Ganta)

[[assertj-core-3.14.0-improvements]]
[.release-note-category]#icon:arrow-circle-up[] Improvements#

- AssertJ's javadoc are now searchable.
- Use beautiful AssertJ's site code style for javadoc :)
- `ObjectAssert.extracting(String...)` learned to extract link:#assertj-core-3.14.0-extract-nested-map[nested map key field/property]. (Sven Johansson)
- Prettify `allOf` and `anyOf` link:#assertj-core-3.14.0-combined-condition-description[combined conditions description]. (Edgar Asatryan)
- Clearly differentiate top level objects in the new recursive comparison.
- Show actual's stack trace in `hasRootCause` and `hasRootCauseMessage` to give users more information. (Oleksii Khomchenko)
- Show actual's stack trace in `hasMessageMatching` and `hasMessageFindingMatch` to give users more information. (Stephen O'Rourke)
- Update message text in `ShouldHaveSameSizeAs` to show both actual and expected collections. (Thami Inaflas)
- Add link:#assertj-core-3.14.0-hamcrest-matching[`matching` syntactic sugar method] to use Hamcrest Matcher as Condition. (Jonas Berlin)
- Update ByteBuddy to version 1.10.2.
- Update Hamcrest to version 2.2.
- Fix javadoc typos and incorrect references. (Erhard Pointl, Stefano Cordio)
- Stop throwing an `IllegalArgumentException` when `isIn` and `isNotIn` are given an empty group of values.
- Expose `AbstractAssert.objects` to be used by subclasses.
- Bump opentest4j from 1.1.1 to 1.2.0. (still optional)
- Improve `HamcrestCondition` generic type inference. (Carter Kozak)
- Remove `shouldHaveThrown(Assertion.class)` used internally. (sowmiyamuthuraman)
- Replace `catchThrowable` + `isInstanceOf(AssertionError.class)` by `expectAssertionError` (internal use). (Clemens Grabmann)
- Rewrite `CompletableFutureAssert` tests with `assertThatAssertionErrorIsThrownBy`.  (internal use). (Clemens Grabmann)

[[assertj-core-3.14.0-fixed]]
[.release-note-category]#icon:wrench[] Fixed#

- Fix `BDDSoftAssertions.then(URL actual)` that just did not work 🤦‍. (Rob Spieldenner)
- Fix possible `MissingFormatArgumentException` in `ShouldHaveMessage` and `ShouldContain`. (Erhard Pointl)
- Fix javadoc search.
- Fix javadoc links. (Stefano Cordio)
- Fix `hasSizeBetween()` that did not work with strings. (Geoffrey Arthaud)
- Fix failing soft assertions when combined with `asInstanceOf`.
- Fix missing soft assertions proxying for `get` of `OptionalAssert`. (Stefano Cordio)
- Make `convert-junit-assertions-to-assertj.sh` conversion script work on Windows. (Michael Keppler)

[[assertj-core-3.14.0-deprecated]]
[.release-note-category]#icon:ban[] Deprecated#

- Deprecate the confusing `containsOnlyElementsOf` in favor of `isSubsetOf` or `hasSameElementsAs`.
- Deprecate `Map` assertions `extracting(Object)` and `extracting(Object...)` in favor of `extractingByKey(KEY)` and `extractingByKeys(KEY...)`, respectively. (Stefano Cordio)


[[assertj-core-3.14.0-bdd-assumptions]]
[.release-note-item]#Add BDD assumptions#

Add Behavior Driven Development style entry point for assumption methods for different types, which allow to skip test execution when assumptions are not met.

The difference with the `Assumptions` class is that entry point methods are named `given` instead of `assumeThat`.

Example:
[source,java,indent=0]
----
String hobbit = "HOBBIT";
List<String> fellowshipOfTheRing = list("Aragorn", "Gandalf", "Frodo", "Legolas");

@Test
public void given_the_assumption_is_not_met_the_test_is_skipped() {
  given(hobbit).isEqualTo("ORC");
  // ... following code is not executed, the test is skipped
  then(fellowshipOfTheRing).contains("Sauron");
}

@Test
public void given_the_assumption_is_met_the_test_is_executed() {
  given(hobbit).isEqualTo("HOBBIT");
  // ... following code is executed and fails!
  then(fellowshipOfTheRing).doesNotContain("Sauron");
}
----

[[assertj-core-3.14.0-spliterator-assertions]]
[.release-note-item]#Add `Spliterator` assertions#

Add `hasCharacteristics` and `hasOnlyCharacteristics` assertions for the link:https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html?is-external=true[`Spliterator`] type.

Example:
[source,java,indent=0]
----
Spliterator<Integer> spliterator = Stream.of(1, 2, 3).spliterator();

assertThat(spliterator).hasCharacteristics(Spliterator.SIZED,
                                           Spliterator.ORDERED)
                       .hasOnlyCharacteristics(Spliterator.SIZED,
                                               Spliterator.SUBSIZED,
                                               Spliterator.IMMUTABLE,
                                               Spliterator.ORDERED);
----

[[assertj-core-3.14.0-isAtSameInstantAs]]
[.release-note-item]#Add `isAtSameInstantAs` to `OffsetDateTime` assertions#

Verifies that actual and given `OffsetDateTime` are at the same `Instant`.

Example:
[source,java,indent=0]
----
OffsetDateTime offsetDateTime1 = OffsetDateTime.of(2000, 12, 12, 3, 0, 0, 0, ZoneOffset.ofHours(3));
OffsetDateTime offsetDateTime2 = OffsetDateTime.of(2000, 12, 12, 0, 0, 0, 0, ZoneOffset.ofHours(0));
// assertion succeeds
assertThat(offsetDateTime1).isAtSameInstantAs(offsetDateTime2);

offsetDateTime2 = OffsetDateTime.of(2000, 12, 12, 2, 0, 0, 0, ZoneOffset.ofHours(0));
// assertion fails
assertThat(offsetDateTime1).isAtSameInstantAs(offsetDateTime2);
----

[[assertj-core-3.14.0-assertAlso]]
[.release-note-item]#Add `assertAlso` `SoftAssertions` method to allow combining different soft assertions instances#

`assertAlso` lets you combine other soft assertions instances together.

Example:
[source,java,indent=0]
----
Mansion mansion = new Mansion();

SoftAssertions check_kitchen() {
  SoftAssertions softly = new SoftAssertions();
  softly.assertThat(mansion.kitchen()).as("Kitchen").isEqualTo("clean");
  return softly;
}

SoftAssertions check_library() {
  SoftAssertions softly = new SoftAssertions();
  softly.assertThat(mansion.library()).as("Library").isEqualTo("clean");
  return softly;
}

@Test
void host_dinner_party_where_nobody_dies() {
  SoftAssertions softly = new SoftAssertions();
  mansion.hostPotentiallyMurderousDinnerParty();
  softly.assertThat(mansion.guests()).as("Living Guests").isEqualTo(7);
  softly.assertThat(mansion.revolverAmmo()).as("Revolver Ammo").isEqualTo(6);
  softly.assertThat(mansion.candlestick()).as("Candlestick").isEqualTo("pristine");
  softly.assertThat(mansion.colonel()).as("Colonel").isEqualTo("well kempt");
  softly.assertThat(mansion.professor()).as("Professor").isEqualTo("well kempt");

  SoftAssertions kitchen = check_kitchen();
  softly.assertAlso(kitchen);

  SoftAssertions library = check_library();
  softly.assertAlso(library);

  softly.assertAll();
}
----

[[assertj-core-3.14.0-isEmpty-isNotEmpty-file-assertions]]
[.release-note-item]#Add `isEmpty` and `isNotEmpty` file assertions#

Verify that the actual `File` is empty (i.e. the file size = 0) or not empty (i.e. the file size > 0) .

Example:
[source,java,indent=0]
----
File file = File.createTempFile("tmp", "txt");

// assertion will pass
assertThat(file).isEmpty();

Files.write(file.toPath(), new byte[]{1, 1});

// assertion will pass
assertThat(file).isNotEmpty();
----

[[assertj-core-3.14.0-hasSize]]
[.release-note-item]#Add `hasSize(long expectedSizeInBytes)` to `File` assertions#

Verifies that the size of the `File` under test is exactly equal to the given size in *bytes*.

Example:
[source,java,indent=0]
----
File file = File.createTempFile("tmp", "bin");
Files.write(file.toPath(), new byte[] {1, 1});

// assertion will pass
assertThat(file).hasSize(2);

// assertion will fail
assertThat(file).hasSize(1);
----

[[assertj-core-3.14.0-bdd-assertions-and]]
[.release-note-item]#Avoid BDDMockito/BDDAssertions `then(object)` clash with `and.then(object)`#

To avoid clash with libraries like Mockito that exposes a static `then(object)` method, you can statically use the `and` field.

[source,java,indent=0]
----
import static org.mockito.BDDMockito.then;
// can't use import static org.assertj.core.api.BDDAssertions.then because of BDDMockito.then;
import static org.assertj.core.api.BDDAssertions.and;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;

// suppress and.then warning: The static method BDDAssertions.then() should be accessed in a static way
@SuppressWarnings("static-access")
@Test
public void bdd_assertions_with_bdd_mockito() {
  // GIVEN
  Person person = mock(Person.class)
  // WHEN
  person.ride(bike);
  person.ride(bike);
  // THEN
  // mockito then()
  then(person).should(times(2)).ride(bike);
  // use AssertJ and.then(person) as then(person) would clash with mockito then(person)
  and.then(person.hasBike()).isTrue();
}
----

[[assertj-core-3.14.0-hasRootCauseMessage]]
[.release-note-item]#Add `hasRootCauseMessage` to `Throwable` assertions#

Verifies that the message of the root cause of the actual `Throwable` is equal to the given one, a simple `String` or `String.format` is supported to specify the expected root cause message.

Example:
[source,java,indent=0]
----
Throwable throwable = new Throwable(new IllegalStateException(new NullPointerException("expected message")));

// assertions will pass
assertThat(throwable).hasRootCauseMessage("expected message")
                     .hasRootCauseMessage("expected %s", "message");

// assertions will fail
assertThat(throwable).hasRootCauseMessage("another message");
assertThat(throwable).hasRootCauseMessage("%s", "message");
// no root cause message
assertThat(new Throwable()).hasRootCauseMessage("%s %s", "expected", "message");
----

[[assertj-core-3.14.0-as-instance-of-assert-factory]]
[.release-note-item]#Add syntax sugar `as(InstanceOfAssertFactory)` to `Assertions` and `WithAssertions` for improved readability#

A syntax sugar to write fluent assertion with methods having an `InstanceOfAssertFactory` parameter. Added as a static method in `Assertions`, it is also available as a default method in the `WithAssertions` interface.

Example:
[source,java,indent=0]
----
Jedi yoda = new Jedi("Yoda", "Green");

assertThat(yoda).extracting(Jedi::getName, as(InstanceOfAssertFactories.STRING))
                .startsWith("Yo");
----

`as(InstanceOfAssertFactory)` can be used together with the following assertion methods:

- link:#assertj-core-3.14.0-extracting-string[`ObjectAssert#extracting(String, InstanceOfAssertFactory)`]
- link:#assertj-core-3.14.0-extracting-function[`ObjectAssert#extracting(Function, InstanceOfAssertFactory)`]
- link:#assertj-core-3.14.0-map-extracting-by-key[`MapAssert#extractingByKey(KEY, InstanceOfAssertFactory)`]
- link:#assertj-core-3.14.0-optional-get[`OptionalAssert#get(InstanceOfAssertFactory)`]

[[assertj-core-3.14.0-extracting-string]]
[.release-note-item]#Add `extracting` with `String` and `InstanceOfAssertFactory` parameters to `Object` assertions#

Extracts the value of given field/property from the object under test, the extracted value becoming the new object under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
// Create frodo, setting its name, age and Race (Race having a name property)
TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);

// let's extract and verify Frodo's name:
assertThat(frodo).extracting("name", as(InstanceOfAssertFactories.STRING))
                 .startsWith("Fro");

// The following assertion will fail as Frodo's name is not an Integer:
assertThat(frodo).extracting("name", as(InstanceOfAssertFactories.INTEGER))
                 .isZero();
----

[[assertj-core-3.14.0-extracting-function]]
[.release-note-item]#Add `extracting` with `Function` and `InstanceOfAssertFactory` parameters to `Object` assertions#

Uses the given `Function` to extract a value from the object under test, the extracted value becoming the new object under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
// Create frodo, setting its name, age and Race (Race having a name property)
TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);

// let's extract and verify Frodo's name:
assertThat(frodo).extracting(TolkienCharacter::getName, as(InstanceOfAssertFactories.STRING))
                 .startsWith("Fro");

// The following assertion will fail as Frodo's name is not an Integer:
assertThat(frodo).extracting(TolkienCharacter::getName, as(InstanceOfAssertFactories.INTEGER))
                 .isZero();
----

[[assertj-core-3.14.0-map-extracting-by-key]]
[.release-note-item]#Add `extractingByKey` with `KEY` and `InstanceOfAssertFactory` parameters to `Map` assertions#

Extracts the value of given key from the map under test, the extracted value becoming the new object under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
Map<String, Object> map = new HashMap<>();
map.put("name", "kawhi");

// The following assertion will succeed:
assertThat(map).extractingByKey("name", as(InstanceOfAssertFactories.STRING))
               .startsWith("kaw");

// The following assertion will fail as the value is not an Integer:
assertThat(map).extractingByKey("name", as(InstanceOfAssertFactories.INTEGER))
               .isZero();
----

[[assertj-core-3.14.0-optional-get]]
[.release-note-item]#Add `get` with `InstanceOfAssertFactory` parameters to `Optional` assertions#

Verifies that the optional is not `null` and not empty and returns an new assertion instance to chain assertions on the optional value.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
Optional<String> optional = Optional.of("Frodo");

// The following assertion will succeed:
assertThat(optional).get(as(InstanceOfAssertFactories.STRING))
                    .startsWith("Fro");

// The following assertion will fail as the value is not an Integer:
assertThat(optional).get(as(InstanceOfAssertFactories.INTEGER))
                    .isZero();
----

[[assertj-core-3.14.0-iterable-first]]
[.release-note-item]#Add `first` with `InstanceOfAssertFactory` parameters to `Iterable` assertions#

Navigates and allows to perform assertions on the first element of the `Iterable` under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
Iterable<String> hobbits = newArrayList("Frodo", "Sam", "Pippin");

// assertion succeeds
assertThat(hobbits).first(as(InstanceOfAssertFactories.STRING))
                   .startsWith("Fro")
                   .endsWith("do");
// assertion fails
assertThat(hobbits).first(as(InstanceOfAssertFactories.STRING))
                   .startsWith("Pip");
// assertion fails because of wrong factory type
assertThat(hobbits).first(as(InstanceOfAssertFactories.INTEGER))
                   .isZero();
----

[[assertj-core-3.14.0-iterable-last]]
[.release-note-item]#Add `last` with `InstanceOfAssertFactory` parameters to `Iterable` assertions#

Navigates and allows to perform assertions on the last element of the `Iterable` under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
Iterable<String> hobbits = newArrayList("Frodo", "Sam", "Pippin");

// assertion succeeds
assertThat(hobbits).last(as(InstanceOfAssertFactories.STRING))
                   .startsWith("Pip")
                   .endsWith("pin");
// assertion fails
assertThat(hobbits).last(as(InstanceOfAssertFactories.STRING))
                   .startsWith("Fro");
// assertion fails because of wrong factory type
assertThat(hobbits).last(as(InstanceOfAssertFactories.INTEGER))
                   .isZero();
----

[[assertj-core-3.14.0-iterable-element]]
[.release-note-item]#Add `element` with `InstanceOfAssertFactory` parameters to `Iterable` assertions#

Navigates and allows to perform assertions on the chosen element of the `Iterable` under test.
The `InstanceOfAssertFactory` parameter is used to get the assertions narrowed to the factory type.

Examples:
[source,java,indent=0]
----
Iterable<String> hobbits = newArrayList("Frodo", "Sam", "Pippin");

// assertion succeeds
assertThat(hobbits).element(1, as(InstanceOfAssertFactories.STRING))
                   .startsWith("Sa")
                   .endsWith("am");
// assertion fails
assertThat(hobbits).element(1, as(InstanceOfAssertFactories.STRING))
                   .startsWith("Fro");
// assertion fails because of wrong factory type
assertThat(hobbits).element(1, as(InstanceOfAssertFactories.INTEGER))
                   .isZero();
----

[[assertj-core-3.14.0-throwable-assertions-string-format]]
[.release-note-item]#Add `String.format` support for expected message in `hasMessageStartingWith`, `hasMessageContaining`, `hasMessageEndingWith` and `hasStackTraceContaining` assertions#

Instead of taking a simple `String` the assertions mentioned above now accept a `String.format` like parameters, i.e. `(String description, Object... parameters)` making it easier to build more involved expected strings.

Examples:
[source,java,indent=0]
----
Throwable throwableWithMessage = new IllegalArgumentException("wrong amount 123");

assertThat(throwableWithMessage).hasMessageStartingWith("%s a", "wrong")
                                .hasMessageContaining("wrong %s", "amount")
                                .hasMessageEndingWith("%s 123", "amount")
                                .hasStackTraceContaining("%s amount", "wrong");
----

[[assertj-core-3.14.0-extract-nested-map]]
[.release-note-item]#`ObjectAssert.extracting(String...)` learned to extract nested map key field/property#

`extracting` is now able to extract a deeply nested map key, before this improvement extracting a value by key was only supported for a `Map` object under test (but not for fields of type `Map`).

Let's clarify things with a concrete example:
[source,java,indent=0]
----
Jedi luke = new Jedi(new Name("Luke", "Skywalker"), 26);
// setAttribute puts a new entry in 'attributes' Map field
luke.setAttribute("side", "light");

Jedi leia = new Jedi(new Name("Leia", "Skywalker"), 26);
// setRelation puts a new entry in 'relations' Map field
luke.setRelation("sister", leia);
leia.setRelation("brother", luke);

assertThat(luke).extracting("name.last",
                            "attributes.side",
                            "relations.sister",
                            "relations.sister.relations.brother")
                .containsExactly("Skywalker",
                                 "light",
                                 leia,
                                 luke);
----

[[assertj-core-3.14.0-combined-condition-description]]
[.release-note-item]#Prettify `allOf` and `anyOf` combined conditions description#

To make it more readable, reformat the error message when multiple combined conditions with `allOf` and `anyOf` fail.

Examples: the following assertion will fail ...
[source,java,indent=0]
----
private static Condition<String> contains(String s) {
  return new Condition<>(value -> value.contains(s), "contains " + s);
}

// failing assertion:
assertThat("Gandalf").has(anyOf(contains("i"),
                                allOf(contains("o"),
                                      anyOf(contains("a"),
                                            contains("b"),
                                            contains("c")))));
----
With the following error message
[source,text,indent=0]
----
Expecting:
 <"Gandalf">
to have:
 <any of:[
   contains i,
   all of:[
      contains o,
      any of:[
         contains a,
         contains b,
         contains c
      ]
   ]
]>
----

[[assertj-core-3.14.0-hamcrest-matching]]
[.release-note-item]#Add `matching` syntactic sugar method to use Hamcrest Matcher as `Condition`#

Syntactic sugar to construct a `Condition` using the Hamcrest Matcher given as a parameter.

Example:
[source,java,indent=0]
----
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.HamcrestCondition.matching;
import static org.hamcrest.core.StringContains.containsString;

@Test
public void matching_example() {
 assertThat("abc").is(matching(containsString("a")));
}
----

[[assertj-core-3-13-2-release-notes]]
==== AssertJ Core 3.13.2

Release date : 2019-08-04

This release ships a few improvements:

* Fixes an annoyance in `InstanceOfAssertFactories`, where `URL` and `URI` constants have been renamed to `URL_TYPE` and `URI_TYPE` respectively to avoid a clash with `java.net.URL` and `java.net.URI`. See https://github.com/joel-costigliola/assertj-core/issues/1567 for details.
* Updates ByteBuddy to version 1.10.0.
* Fixes some javadoc typos.
* Enforces banned dependencies with `maven-enforcer-plugin`.

[[assertj-core-3-13-1-release-notes]]
==== AssertJ Core 3.13.1

Release date : 2019-07-29

This release addresses the 3.13.0 https://github.com/joel-costigliola/assertj-core/issues/1563[issue] by which AssertJ required OpenTest4J to be on the classpath otherwise a `java.lang.NoClassDefFoundError: org/opentest4j/MultipleFailuresError` would be raised. Thanks Pascal Schumacher for the quick fix!

[source,text,indent=0]
----
java.lang.NoClassDefFoundError: org/opentest4j/MultipleFailuresError
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:174)
	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:802)
	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:700)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:623)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.assertj.core.internal.Failures.<init>(Failures.java:46)
	at org.assertj.core.internal.Failures.<clinit>(Failures.java:44)
	at org.assertj.core.internal.Objects.<init>(Objects.java:87)
	at org.assertj.core.internal.Objects.<init>(Objects.java:101)
	at org.assertj.core.internal.Objects.<clinit>(Objects.java:82)
	at org.assertj.core.api.AbstractAssert.<init>(AbstractAssert.java:65)
	at org.assertj.core.api.AbstractCharSequenceAssert.<init>(AbstractCharSequenceAssert.java:53)
	at org.assertj.core.api.AbstractStringAssert.<init>(AbstractStringAssert.java:28)
	at org.assertj.core.api.StringAssert.<init>(StringAssert.java:25)
	at org.assertj.core.api.AssertionsForClassTypes.assertThat(AssertionsForClassTypes.java:484)
	at org.assertj.core.api.Assertions.assertThat(Assertions.java:2585)
----

[[assertj-core-3-13-0-release-notes]]
==== AssertJ Core 3.13.0

Release date : 2019-07-28

The highlight of this release is the addition of `asInstanceOf` which allows to chain specific type assertions from a value that was initially declared with a different type (usually `Object`). Thanks Stefano Cordio for this contribution!

Example:
[source,java,indent=0]
----
Object value = "abc";

// This line DOES NOT COMPILE since startsWith is a String assertion and value is an Object
assertThat(value).startsWith("ab");

// This line COMPILES because we tell AssertJ to consider value as a String
assertThat(value).asInstanceOf(InstanceOfAssertFactories.STRING).startsWith("ab");
----
This feature is more detailed in the notes below.

[[assertj-core-3.13.0-contributors]]
[.release-note-category]#icon:user[] Contributors#

Thanks to all the contributors of this release:

Pascal Schumacher, Erhard Pointl, Stefano Cordio, Thomas Traude, Andrei Solntsev, Matej Drobnič, Željko Mirović, Mike Gilchrist, Phillip Webb, Michal Fotyga,Valeriy Vyrva, Eddú Meléndez Gonzales, GaspardPO, Bengt Brodersen, Jiri Pejchal, Christian Stein, Nikolaos Georgiou and Sam Brannen.

Special thanks to Nils Winkler for his work on the assertions conversion scripts and Stefano Cordio for the `asInstanceOf` contribution.

[[assertj-core-3.13.0-breaking-changes]]
[.release-note-category]#icon:exclamation-triangle[] Breaking changes#

* As the link:#assertj-core-3.13.0-extracting[`extracting(String)`] method for `Object` and `Map` extracts only one value, it now returns `Object` assertions instead of list assertions (on a singleton list). This means that any list assertions used won't compile anymore, they need to be replaced by `Object` assertions.

[source,java,indent=0]
----
// GIVEN
Map<String, Object> basketballPlayer = new HashMap<>();
basketballPlayer.put("name", "kawhi");
basketballPlayer.put("age", 25);

// Does not compile anymore!
assertThat(basketballPlayer).extracting("name")
                            .containsExactly("kawhi"); // DOES NOT COMPILE

// Use Object assertions like isEqualTo
assertThat(basketballPlayer).extracting("name")
                            .isEqualTo("kawhi");

// multiple values work as before, no problem there!
assertThat(basketballPlayer).extracting("name", "age")
                            .containsExactly("kawhi", 25);
----


* In the new recursive comparison, we now use the expected field as a reference to determine how to compare it to corresponding the actual field.
Sorted vs non sorted collections comparison semantics have been replaced by ordered vs unordered collections semantics (ordered types are `List`, `SortedSet` and `LinkedHashSet`).
As a consequence of the two previous points, when comparing collection/map fields, if the actual field is ordered and the expected is unordered, the comparison is allowed but not the other way around (unless order is ignored explicitely in the comparison configuration).

[[assertj-core-3.13.0-new-features]]
[.release-note-category]#icon:plus-circle[] New features#

- Add link:#assertj-core-3.13.0-asInstanceOf[`asInstanceOf`] to chain specific type assertions. (Stefano Cordio)
- Add link:#assertj-core-3.13.0-extracting[`extracting(String)`] to `Object` and `Map` assertions. (Stefano Cordio)
- Add a way to link:#assertj-core-3.13.0-global-configuration[configure AssertJ] for all tests.
- Add link:#assertj-core-3.13.0-hasCauseReference[`hasCauseReference`] throwable assertion. (Mike Gilchrist)
- Add link:#assertj-core-3.13.0-directory-assertions[directory content assertions] for `File` and `Path`. (Valeriy Vyrva)
- Add link:#assertj-core-3.13.0-throwable-message-assertions[`hasMessageContainingAll` and `hasMessageNotContainingAny`] to throwable assertions. (Phillip Webb)
- Allow using any link:#assertj-core-3.13.0-check-soft-assertions-with-any-custom-assertions[custom assertions in soft assertions]. (Bengt Brodersen)
- Add link:#assertj-core-3.13.0-containsExactlyInAnyOrderEntriesOf[`containsExactlyInAnyOrderEntriesOf`] to map assertions. (Stefano Cordio)
- Add link:#assertj-core-3.13.0-isCloseToUtcNow[`isCloseToUtcNow`] to `LocalDateTime` and `OffsetDateTime` assertions. (Nikolaos Georgiou)

[[assertj-core-3.13.0-improvements]]
[.release-note-category]#icon:arrow-circle-up[] Improvements#

- Junit 4/5 and TestNG assertions convertion scripts improvements. (Nils Winkler)
- Add support for link:#assertj-core-3.13.0-millisecond-and-timezone-parsing[combined millisecond and timezone parsing]. (Matej Drobnič)
- Add support for link:#assertj-core-3.13.0-optional-support-in-recursive-comparison[`Optional` in the new recursive comparison].
- Allow link:#assertj-core-3.13.0-ignore-order-in-recursive-comparison[ignoring collection order] in specific fields in the new recursive comparison. (Željko Mirović)
- Make `catchThrowableOfType` easier to discover in the javadoc.
- Rename methods `isBeforeOrEqualsTo` and `isAfterOrEqualsTo` to `isBeforeOrEqualTo` and `isAfterOrEqualTo`. (Eddú Meléndez Gonzales)
- Improve error messages in the new recursive comparison when group size differs or when trying to compare actual unordered vs expected ordered.
- Introduce explicit module descriptor. (Christian Stein)
- Allow returned values of `WithAssertions#fail` methods to be ignored by findbugs/spotbugs. (Jiri Pejchal)
- Improve the error message when multiple (soft) assertions error are raised.
- link:#assertj-core-3.13.0-extracting-type-propagation[Propagate value type with `extracting(Function)`]. (Stefano Cordio)

[[assertj-core-3.13.0-fixed]]
[.release-note-category]#icon:wrench[] Fixed#

- Fix link:index.html#assertj-core-junit5-soft-assertions[Soft assertions JUnit 5 extension] that did not support parallel test nor `@TestInstance(PER_CLASS)` lifecycle semantics. (Sam Brannen)
- Fix JavaDoc regarding `AnyOf` and `AllOf`. (Thomas Traude)
- Make sure that `isEqualTo("abc")` is not resolved to `isEqualTo(String, Object... args)`. (Andrei Solntsev)
- Fix Javadoc typos. (GaspardPO, Michal Fotyga)
- Fix typo in error message factories `ShouldBeBeforeOrEqualTo` and `ShouldBeAfterOrEqualTo`. (Stefano Cordio)

[[assertj-core-3.13.0-deprecated]]
[.release-note-category]#icon:ban[] Deprecated#

- Deprecate Java 6/Android assertions entry points as they don't truly provide 100% Java 6/Android compatibility.
- Deprecate methods `isBeforeOrEqualTo` and `isAfterOrEqualTo` in favor of `isBeforeOrEqualsTo` and `isAfterOrEqualsTo` (Eddú Meléndez Gonzales).
- Deprecate `JUnitJupiterSoftAssertions` and  `JUnitJupiterBDDSoftAssertions` in favor of `SoftAssertionsExtension`

[[assertj-core-3.13.0-asInstanceOf]]
[.release-note-item]#Add `asInstanceOf` to chain specific type assertions#

`asInstanceOf` allows to chain specific type assertions from a value initially declared as a less specific type (often `Object`).

Let's start with the problem `asInstanceOf` is solving: in the following example we would like to call `String` assertions but this is not possible since `value` is declared as an `Object` thus only `Object` assertions are accessible.
[source,java,indent=0]
----
// Given a String declared as an Object
Object value = "Once upon a time in the west";

// We would like to call String assertions but this is not possible since value is declared as an Object
assertThat(value).startsWith("ab"); // this does not compile !
----

Thanks to `asInstanceOf` we can now tell AssertJ to consider `value` as a `String` in order to call `String` assertions.
To do so we need to pass an `InstanceOfAssertFactory` that can build a `StringAssert`, fortunately you don't have to write it, it is already available in `InstanceOfAssertFactories`!

[source,java,indent=0]
----
import static org.assertj.core.api.InstanceOfAssertFactories.STRING;

// Given a String declared as an Object
Object value = "Once upon a time in the west";

// With asInstanceOf, we switch to specific String assertion by specifying the InstanceOfAssertFactory for String
assertThat(value).asInstanceOf(STRING).startsWith("Once");
----

AssertJ verifies that the actual value is compatible with the assertions `InstanceOfAssertFactory` is going to give access to.

`InstanceOfAssertFactories` provides static factories for all types AssertJ provides assertions for, additional factories can be created with custom `InstanceOfAssertFactory` instances.

Here's another example showing the parameterized type support:
[source,java,indent=0]
----
// Actually a List<TolkienCharacter>
Object hobbits = list(frodo, pippin, merry, sam);

// As we specify the TolkienCharacter class, the following chained assertion expect to be given TolkienCharacters.
// This means that method like extracting or filteredOn are given a TolkienCharacter
assertThat(hobbits).asInstanceOf(InstanceOfAssertFactories.list(TolkienCharacter.class))
                   .contains(frodo, sam)
                   .extracting(TolkienCharacter::getName)
                   .contains("Frodo", "Sam");

// Use LIST if the elements type is not important but note that the chained assertions
// will be given Object not TolkienCharacter
assertThat(hobbits).asInstanceOf(InstanceOfAssertFactories.LIST)
                    //.extracting(TolkienCharacter::getName) does not work as extracting is given an Object
                   .contains(frodo);
----

[[assertj-core-3.13.0-extracting]]
[.release-note-item]#Add `extracting` with single parameter to `Object` and `Map` assertions#

Extracts the value of given field/property from the object under test, the extracted value becoming the new object under test.

Examples:
[source,java,indent=0]
----
// Create frodo, setting its name, age and Race (Race having a name property)
TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);

// let's extract and verify Frodo's name:
assertThat(frodo).extracting("name")
                 .isEqualTo("Frodo");

// The extracted value being a String, we would like to use String assertions but we can't due to Java generics limitations.
// The following assertion does NOT compile:
assertThat(frodo).extracting("name")
                 .startsWith("Fro");

// To get String assertions use asInstanceOf:
assertThat(frodo).extracting("name")
                 .asInstanceOf(InstanceOfAssertFactories.STRING)
                 .startsWith("Fro");
----

If the object under test is a Map, the parameter is used as a key to the map.

Example:
[source,java,indent=0]
----
Map<String, Object> basketballPlayer = new HashMap<>();
basketballPlayer.put("name", "kawhi");
basketballPlayer.put("age", 25);

// single value
assertThat(basketballPlayer).extracting("name")
                            .isEqualTo("kawhi");
----

[[assertj-core-3.13.0-global-configuration]]
[.release-note-item]#AssertJ global configuration#

AssertJ 3.13.0 introduces a `Configuration` class allowing to change AssertJ behavior and a way to register automatically.
Read <<assertions-guide#assertj-core-configuration, Configuring AssertJ>> chapter to learn about it.


[[assertj-core-3.13.0-hasCauseReference]]
[.release-note-item]#Add `hasCauseReference` to throwable assertions#

Verifies that the actual `Throwable` has a cause that refers to the given one, i.e. using == comparison.

Example:
[source,java,indent=0]
----
Throwable invalidArgException = new IllegalArgumentException("invalid arg");
Throwable throwable = new Throwable(invalidArgException);

// This assertion succeeds:
assertThat(throwable).hasCauseReference(invalidArgException);

// These assertions fail:
assertThat(throwable).hasCauseReference(new IllegalArgumentException("invalid arg"));
assertThat(throwable).hasCauseReference(new NullPointerException());
assertThat(throwable).hasCauseReference(null); // prefer hasNoCause()
----


[[assertj-core-3.13.0-directory-assertions]]
[.release-note-item]#New directory content assertions#

The new assertions have been added for both `File` and `Path`, they add support for

* checking what a directory contains with <<assertj-core-3.13.0-isDirectoryContaining, `isDirectoryContaining`>>
* checking what a directory does not contain with <<assertj-core-3.13.0-isDirectoryNotContaining, `isDirectoryNotContaining`>>
* checking if directory is empty with <<assertj-core-3.13.0-isEmptyDirectory, `isEmptyDirectory`>> or not with <<assertj-core-3.13.0-isNotEmptyDirectory, `isNotEmptyDirectory`>>

Both `isDirectoryContaining` and `isDirectoryNotContaining` accept either `Predicate` or `String` parameters, the `String` one being interpreted as a https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html?is-external=true#getPathMatcher(java.lang.String)[path matcher].

As `File` and `Path` assertions are similar, the examples will only show `File` assertions.

The examples use the following directory structure:
[source,text,indent=0]
----
/root/
/root/sub-dir-1/
/root/sub-dir-1/file-1.ext
/root/sub-dir-1/file-2.ext
/root/sub-dir-2/
/root/sub-file-1.ext
/root/sub-file-2.ext
----

[[assertj-core-3.13.0-isDirectoryContaining]]
`isDirectoryContaining` assertions examples:
[source,java,indent=0]
----
File root = new File("root");

// Successfull assertions with predicate parameter:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("sub-dir"))
                .isDirectoryContaining(file -> file.getName().startsWith("sub-file"))
                .isDirectoryContaining(file -> file.getName().endsWith(".ext"))
                .isDirectoryContaining(File::isDirectory);

// Successfull assertions with String path matcher parameter:
assertThat(root).isDirectoryContaining("glob:**sub-dir*")
                .isDirectoryContaining("glob:**sub-file*")
                .isDirectoryContaining("glob:**.ext")
                .isDirectoryContaining("regex:.*ext")
                .isDirectoryContaining("glob:**.{ext,bin");


// The following assertions fail:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("dir"));
assertThat(root).isDirectoryContaining(file -> file.getName().endsWith(".bin"));
assertThat(root).isDirectoryContaining("glob:**dir");
assertThat(root).isDirectoryContaining("glob:**.bin");
----

[[assertj-core-3.13.0-isDirectoryNotContaining]]
`isDirectoryNotContaining` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// Successfull assertions with predicate parameter:
assertThat(root).isDirectoryNotContaining(file -> file.getName().startsWith("dir"))
                .isDirectoryNotContaining(file -> file.getName().endsWith(".bin"));

// Successfull assertions with String path matcher parameter:
assertThat(root).isDirectoryNotContaining("glob:**dir")
                .isDirectoryNotContaining("glob:**.bin")
                .isDirectoryNotContaining("regex:.*bin")
                .isDirectoryNotContaining("glob:**.{java,class}");

// The following assertions fail:
assertThat(root).isDirectoryContaining(file -> file.getName().startsWith("dir"));
assertThat(root).isDirectoryContaining(file -> file.getName().endsWith(".bin"));
assertThat(root).isDirectoryNotContaining("glob:**sub-dir*");
assertThat(root).isDirectoryNotContaining("regex:.*ext");
assertThat(root).isDirectoryNotContaining("glob:**.{ext,bin");
----

[[assertj-core-3.13.0-isEmptyDirectory]]
`isEmptyDirectory` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// The following assertion succeeds:
assertThat(new File(root, "sub-dir-2")).isEmptyDirectory();

// The following assertions fail:
assertThat(root).isEmptyDirectory();
assertThat(new File(root, "sub-dir-1")).isEmptyDirectory();
----

[[assertj-core-3.13.0-isNotEmptyDirectory]]
`isNotEmptyDirectory` assertion examples:
[source,java,indent=0]
----
File root = new File("root");

// The following assertions succeed:
assertThat(root).isNotEmptyDirectory();
assertThat(new File(root, "sub-dir-1")).isNotEmptyDirectory();

// The following assertion fails:
 assertThat(new File(root, "sub-dir-2")).isNotEmptyDirectory();
----

[[assertj-core-3.13.0-throwable-message-assertions]]
[.release-note-item]#Add `hasMessageContainingAll` and `hasMessageNotContainingAny` to throwable assertions#

These assertions are the equivalent of `hasMessageContaining` and `hasMessageNotContaining` but accepting multiple String parameters instead of only one.

Example:
[source,java,indent=0]
----
Throwable throwableWithMessage = new IllegalArgumentException("wrong amount 123");
Throwable throwableWithoutMessage = new IllegalArgumentException();

// assertion will pass:
assertThat(throwableWithMessage).hasMessageContainingAll("amount", "123")
                                .hasMessageNotContainingAny("foo", "234");

assertThat(throwableWithoutMessage).hasMessageNotContainingAny("234");

// assertions will fail:
assertThat(throwableWithMessage).hasMessageContainingAll("234");
assertThat(throwableWithoutMessage).hasMessageContainingAll("123");

assertThat(throwableWithMessage).hasMessageNotContainingAny("foo", "amount");
----


The same assertions have been added to `ThrowableAssertAlternative` with these names `withMessageContainingAll` and `withMessageNotContainingAny`:

[source,java,indent=0]
----
Throwable illegalArgumentException = new IllegalArgumentException("wrong amount 123");

// assertions will pass
assertThatExceptionOfType(Throwable.class)
          .isThrownBy(() -> {throw illegalArgumentException;})
          .withMessageContainingAll("amount", "123")
          .withMessageNotContainingAny("foo", "234");
----

[[assertj-core-3.13.0-check-soft-assertions-with-any-custom-assertions]]
[.release-note-item]#Allow using any custom assertions in soft assertions#

The new `check​` method catches and collect assertion errors coming from standard and custom assertions.

Example:
[source,java,indent=0]
----
SoftAssertions softly = new SoftAssertions();

// custom assertions
softly.check(() -> LotrAssertions.assertThat(frodo).hasName("Frodon"));
softly.check(() -> LotrAssertions.assertThat(frodo).hasName("Frodo"));

// standard assertions
softly.assertThat("foo").startsWith("bar");
// could be written with check like (but it's as elegant as the standard use):
// softly.check(() -> Assertions.assertThat("foo").startsWith("bar"));

// 2 errors: "foo" does not start with "bar" and frodo's name is not "Frodon"
assertThat(softly.errorsCollected()).hasSize(2);
----

[[assertj-core-3.13.0-containsExactlyInAnyOrderEntriesOf]]
[.release-note-item]#Add `containsExactlyInAnyOrderEntriesOf` to map assertions#

Verifies that the actual map contains only the given entries and nothing else, in any order.

This is the same assertion as `containsOnly(Map.Entry... entries)`, it simply handles the conversion of `Map.entrySet()` to array.


Example :

[source,java,indent=0]
----
Map<Ring, TolkienCharacter> ringBearers = newLinkedHashMap(entry(oneRing, frodo),
                                                           entry(nenya, galadriel),
                                                           entry(narya, gandalf));
// assertion will pass
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(narya, gandalf)));
// assertion will pass although actual and expected order differ
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(nenya, galadriel),
                                                                            entry(narya, gandalf),
                                                                            entry(oneRing, frodo)));
// assertion will fail as actual does not contain all entries of expected
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(oneRing, frodo)));
// assertion will fail as actual and expected have different sizes
assertThat(ringBearers).containsExactlyInAnyOrderEntriesOf(newLinkedHashMap(entry(oneRing, frodo),
                                                                            entry(nenya, galadriel),
                                                                            entry(narya, gandalf),
                                                                            entry(narya, gandalf)));
----

[[assertj-core-3.13.0-isCloseToUtcNow]]
[.release-note-item]#Add `isCloseToUtcNow` to `LocalDateTime` and `OffsetDateTime` assertions#

Verifies that the actual `LocalDateTime`/`OffsetDateTime` is close to the current date and time on the UTC timezone, according to the given offset.

You can build the offset parameter using `Assertions.within(long, TemporalUnit)` or `Assertions.byLessThan(long, TemporalUnit)`.

If the difference is equal to the offset, the assertion succeeds.

Example with `LocalDateTime`:

[source,java,indent=0]
----
LocalDateTime actual = LocalDateTime.now(Clock.systemUTC());

// assertion will pass if executed less than one second after actual was built
assertThat(actual).isCloseToUtcNow(byLessThan(1, ChronoUnit.SECONDS));

// assertion will fail
assertThat(actual.plusSeconds(2)).isCloseToUtcNow(within(1, ChronoUnit.SECONDS));
----

The same example works with `OffsetDateTime` by simply defining `actual` as:
[source,java,indent=0]
----
OffsetDateTime actual = OffsetDateTime.now(Clock.systemUTC());
----

[[assertj-core-3.13.0-millisecond-and-timezone-parsing]]
[.release-note-item]#Add support for combined millisecond and timezone parsing#

Add `yyyy-MM-dd HH:mm:ss.SSSX` to the default date formats AssertJ supports in `Date` assertions that take a `String` parameter representating a `Date`.

Here's an example of string following this format: `"2003-04-26T00:00:00.123+00:00"`.

Example:

[source,java,indent=0]
----
// GIVEN
SimpleDateFormat isoFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
isoFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
// WHEN
Date date = isoFormat.parse("2003-04-26T00:00:00.123");
// THEN
assertThat(date).isEqualTo("2003-04-26T00:00:00.123+00:00");
----

[[assertj-core-3.13.0-optional-support-in-recursive-comparison]]
[.release-note-item]#Add support for `Optional` in the new recursive comparison#

The recursive comparison added in 3.12.0 now compares `Optional` values recursively instead of comparing `Optional` with `equals`. This is consistent with comparing list elements by elements as an `Optional` can be seen as a list with at most one element.

Example:

[source,java,indent=0]
----
// Song constructor parameters: song, author and coAuthor (optional)
Song song = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
Song expectedSong = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
// THEN
assertThat(song).usingRecursiveComparison()
                .isEqualTo(expectedSong);
----

where `Song` and `Author` don't override `equals`:

[source,java,indent=0]
----
class Song {

  Author author;
  Optional<Author> coAuthor;
  String song;

  Song(String song, Author author, Author coAuthor) {
    this.song = song;
    this.author = author;
    this.coAuthor = Optional.ofNullable(coAuthor);
  }

  // no equals!
}

class Author {

  String name;

  Author(String name) {
    this.name = name;
  }

  String getName() {
    return name;
  }

  // no equals!
}
----

If we fail the test \...

[source,java,indent=0]
----
Song song = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Jimi Hendrix"));
Song expectedSong = new Song("I Can't Get No Satisfaction", new Author("Mick Jagger"), new Author("Keith Richards"));
// FAIL
assertThat(song).usingRecursiveComparison()
                .isEqualTo(expectedSong);
----

\... here's the error reported:

[source,text,indent=0]
----
Expecting:
  <Song [author=Mick Jagger, coAuthor=Optional[Jimi Hendrix], song=I Can't Get No Satisfaction]>
to be equal to:
  <Song [author=Mick Jagger, coAuthor=Optional[Keith Richards], song=I Can't Get No Satisfaction]>
when recursively comparing field by field, but found the following difference:

field/property 'coAuthor.value.name' differ:
- actual value   : "Jimi Hendrix"
- expected value : "Keith Richards"

The recursive comparison was performed with this configuration:
- overridden equals methods were used in the comparison
- these types were compared with the following comparators:
  - java.lang.Double -> DoubleComparator[precision=1.0E-15]
  - java.lang.Float -> FloatComparator[precision=1.0E-6]
- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).
----

[[assertj-core-3.13.0-ignore-order-in-recursive-comparison]]
[.release-note-item]#Allow ignoring collection order in the new recursive comparison#

The recursive comparison added in 3.12.0 can now ignore collection order in all fields in the object under test, this is handy when comparing list to set fields where only the content is relevant but not the order.

Example:

[source,java,indent=0]
----
public class Person {
  String name;
  List<Person> friends = new ArrayList<>();
}

Person sherlock1 = new Person("Sherlock Holmes");
sherlock1.friends.add(new Person("Dr. John Watson"));
sherlock1.friends.add(new Person("Molly Hooper"));

Person sherlock2 = new Person("Sherlock Holmes");
sherlock2.friends.add(new Person("Molly Hooper"));
sherlock2.friends.add(new Person("Dr. John Watson"));

// assertion succeeds as all fields collection order is ignored in the comparison
assertThat(sherlock1).usingRecursiveComparison()
                     .ignoringCollectionOrder()
                     .isEqualTo(sherlock2);

// assertion fails as fields collection order is not ignored in the comparison
assertThat(sherlock1).usingRecursiveComparison()
                     .isEqualTo(sherlock2);
----

[[assertj-core-3.13.0-extracting-type-propagation]]
[.release-note-item]#Propagate value type with `extracting(Function)`#

`extracting(Function)` learned to propagate the type parameter of the resulting `ObjectAssert`  allowing then to chain other type aware methods (e.g. additional extracting).

Example:

[source,java,indent=0]
----
// Old implementation
assertThat(yoda).extracting(Jedi::getName) // ObjectAssert<Object>
                .extracting(String::length) // Not compiling
                .isEqualTo(4);

// New implementation
assertThat(yoda).extracting(Jedi::getName) // ObjectAssert<String>
                .extracting(String::length)  // Compiling!
                .isEqualTo(4);
----

[[assertj-core-3-12-2-release-notes]]
==== AssertJ Core 3.12.2

The main issue fixed was to ignore static methods when finding property accessors (contributed by Andy Wilkinson) which could break some tests since bare name method introspection was introduced in 3.12.0.

`anySatisfy` for `Maps` was improved and does not continue evaluating elements once a match is found (contributed by Erhard Pointl).

[[assertj-core-3-12-1-release-notes]]
==== AssertJ Core 3.12.1

Fix a regression that included a bad module-info.class (thanks Jaro Kuruc) and other minor improvements.

[[assertj-core-3-12-0-release-notes]]
==== AssertJ Core 3.12.0

Release date : 2019-02-14

The main feature of this release is a beta version of the link:#assertj-core-recursive-comparison[new Recursive comparison API]!
It covers what `isEqualToComparingFieldByFieldRecursively` used but easier to use and with more capabilities.

It is a Beta version because we want to have feedback from the community to make it even better before freezing the API.
There are more capabilities to come in the next releases, stay tuned!

===== Contributors

Big thanks to all the contributors of this release:

Pascal Schumacher, Erhard Pointl, Vladimir Chernikov, Sandra Parsick, Martin Tarjanyi, Stephan Windmüller, Yaroslav Mitsynskiy, Thomas Traude, Georg Berky, Tomek Kaczanowski, Lukáš Křečan, Yoann Rodière, Filip Hrisafov, Steven Schlansker, Jeremy Landis, Jack Gough, Sebastian Kempken, Stefan Mandel, Alexandre de Champeaux, Arvid Heise, Jeff Walker, Dmitrii Priporov and Joshua Kitchen.

[[assertj-core-3.12.0-breaking-changes]]
===== Breaking changes

- Introduce first class `Iterator` assertions (Stephan Windmüller).

WARNING: This removes the previously supported "`Iterable`" assertions (like `containsOnly`), call http://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIteratorAssert.html#toIterable--[`IteratorAssert#toIterable`] to access them again, ex:

[source,java,indent=0]
----
Iterator<String> bestBasketBallPlayers = getBestBasketBallPlayers();

assertThat(bestBasketBallPlayers).toIterable().contains("Jordan", "Magic", "Lebron");
----

- Add configurable support for bare-named property introspection. (Steven Schlansker)

AssertJ uses introspection in various places, one example is extracting properties as in `extracting("name")`. AssertJ is able to get values with getters like `getName()`, with this improvement it now can get property values with bare name method like `name()`.

WARNING: Bare-named property introspection is enabled by default and thus changes AssertJ behavior which can break some existing tests relying on introspection, this is especially true as AssertJ wrongly tries static methods (https://github.com/joel-costigliola/assertj-core/issues/1458 had been created to address that).

It is possible to avoid this problem by calling `Assertions.setExtractBareNamePropertyMethods(false);` before every impacted tests.

This is a bit tedious but an improvement is planned in the next release to provide a place to perform global configuration with the same mechanism allowing to link:#assertj-core-custom-representation-default-global-scope[register a custom representation].


===== New features

- New Recursive comparison API! (Beta version)
- Add `satisfiesAnyOf` base assertion. TODO document
- Add `isAbstract` to `Class` assertions. (Erhard Pointl)
- Add `hasValueCloseTo(percentage)` to `OptionalDouble` assertion. (Joshua Kitchen)
- Add `hasOnlyOneElementSatisfying(Consumer)` to `AtomicReferenceArray` assertions. (Vladimir Chernikov)
- Add `hasAllNullFieldsOrProperties` and `hasAllNullFieldsOrPropertiesExcept`. (Vladimir Chernikov)
- Add `hasSizeGreaterThan`, `hasSizeLessThanOrEqualTo`, `hasSizeGreaterThanOrEqualTo` and `hasSizeGreaterThan` to `CharSequence` and `String` assertions. (Sandra Parsick)
- Add `hasSizeGreaterThan`, `hasSizeLessThanOrEqualTo`, `hasSizeGreaterThanOrEqualTo`, `hasSizeGreaterThan` and `hasSizeBetween` to object and primitives array, `Iterable` and `Map`. (Martin Tarjanyi)
- Add `hasSizeBetween` to `CharSequence` and `String` assertions. (Martin Tarjanyi)
- Add `noneSatisfy(BiConsumer)` to `Map` assertions. (Erhard Pointl)
- Add `containsExactlyEntriesOf` assertion to check that a `Map` contains exactly all entries of another `Map`. (Filip Hrisafov)
- Add `containsOnlyKeys(Iterable keys)` to `Map` assertion. (Sebastian Kempken)
- Add `anySatifies(BiConsumer)` to `Map` assertion. (Stefan Mandel)
- Add `hasMessageNotContaining` to `Throwable` assertions. (Georg Berky and Sandra Parsick)
- Add `shouldHaveRootCause` to `Throwable` assertions to check the content of a root cause. (Jack Gough)
- Add `isEqualTo(String string, Objects... param)` to `String` assertion. (Dmitrii Priporov)
- Add `assertThatObject`/`thenObject` to force Object assertion. (Arvid Heise)
- Add JUnit5 to AssertJ assertions migration script for osx. (Tomek Kaczanowski)

===== Improvements

- Add stack trace of original exception to `catchThrowableOfType`. (Sam Smyth)
- `anySatisfy` and `noneSatisfy` now reports all failing elements. (Erhard Pointl)
- `ElementsShouldSatisfy` now uses the configured `Representation` to format objects.
- `ZipSatisfyError` now uses the configured `Representation` to format objects. (Jeff Walker)
- AssertJ `Double` and `Float` comparators now support `Infinity`. (Alexandre de Champeaux)
- Throw `AssertionFailedError` instead of `AssertionError` in some `String` assertions to allow IDEs to show `actual` vs `expected` visual differences. (Yaroslav Mitsynskiy)
- `Optional` `hasValue`/`contains` assertions throws `AssertionFailedError` to allow IDEs to show `actual` vs `expected` visual differences.
- Annotate `Assertions` and `Assumptions` classes with `@CheckReturnValue` and annotate methods to exclude from checking with `@CanIgnoreReturnValue`. (Pascal Schumacher)
- The error message of `allSatisfy(BiConsumer)` `Map` assertion now reports all failing entries instead of the first one. (Stefan Mandel)
- Add missing `@Since` annotations. (Erhard Pointl)
- Get rid of `Arguments` usage when possible in unit tests. (Erhard Pointl)
- Unit tests code cleanup and better use of JUnit 5. (Erhard Pointl, Pascal Schumacher and Jack Gough)
- Update to JUnit 5.4.0. (Erhard Pointl)
- Update to opentest4j to 1.1.1. (Erhard Pointl)
- Update to Byte Buddy 1.9.10. (Pascal Schumacher)
- Update Maven version to and the Maven wrapper. (Thomas Traude, Jeremy Landis)
- Do not proxy `useComparator` method in soft assertions. (Lukáš Křečan)
- Fix an NPE in `ObjectArrays#assertHasOnlyElementsOfType`. (Yoann Rodière)
- Deprecate `Extractor` in favor of `java.util.function.Function`. (Filip Hrisafov)

===== Fixed

- Use `@CanIgnoreReturnValue` on `Assertions` `fail*` methods to revert the effect of the default `@CheckReturnValue` annotation. (Erhard Pointl)
- Fix `ElementsShouldSatisfy` that failed to handle objects whose string representation contained `%`.
- Fix `ElementsShouldZipSatisfy` that failed to handle objects whose string representation contained `%`. (Arvid Heise)
