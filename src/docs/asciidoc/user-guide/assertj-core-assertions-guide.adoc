[[assertj-core-assertions-guide]]
=== Core assertions guide

This section describes the assertions provided by AssertJ Core and other useful features to get the best of it.

AssertJ Core http://www.javadoc.io/doc/org.assertj/assertj-core/[javadoc] explains each assertions most of them with code examples so be sure to check it if you want to know what a specific assertion does. 

[[assertj-core-simple-example]]
==== A simple example

Let's start with a simple example showing a few important things.

[source,java,indent=0]
----
include::{testDir}/example/core/SimpleAssertionsExample.java[tags=user_guide]
----
<1> Statically import `org.assertj.core.api.Assertions.assertThat`
<2> Pass the object under test as the sole `assertThat()` parameter
<3> Use code completion to discover and call assertions
<4> Chain as many assertions as you need

Except for `isNotNull` which is a base assertion, the other assertions are `String` specific as our object under test is a `String`.

[[assertj-core-supported-types]]
==== Supported type assertions

AssertJ provides assertions specific to the object under test type, the following sections list the supported types grouped by categories.

The provided assertions for each of these types are documented later on.

===== Common types

[cols="2"]
|===
| BigDecimal | BigInteger
| CharSequence | Class
| Date | File
| Future / CompletableFuture | InputStream
| Iterable (including any kind of Collection) | Iterator
| List | Map
| Object
| Object[]
a|

* Optional
* OptionalInt /  OptionalLong / OptionalDouble
| Path | Predicate
| Stream
| String  | Throwable / Exception
| URL and URI
|===


===== Primitive types

[cols="2"]
|====
a| Primitive types and their wrapper:

* short / Short
* int / Integer
* long / Long
* byte / Byte
* char / Character
* float / Float
* double / Double

a| Primitive type arrays:

* short[]
* int[]
* long[]
* byte[]
* char[]
* float[]
* double[]
|====

===== Java 8 Temporal types

[cols="2"]
|====
| Instant
| LocalDate
| LocalDateTime
| LocalTime
| OffsetDateTime
| OffsetTime
| ZonedDateTime
|====

===== Atomic types

[cols="2"]
|====
a| Atomic basic types:

* AtomicInteger
* AtomicLong
* AtomicBoolean

a| Atomic array types:

* AtomicIntegerArray
* AtomicLongArray

a| Atomic reference types:

* AtomicMarkableReference
* AtomicStampedReferenceAssert

a| Atomic updater types:

* AtomicIntegerFieldUpdater
* AtomicLongFieldUpdater
* AtomicReferenceFieldUpdater

a| Adder types:

* LongAdder

a|
|====

[[assertj-core-assertion-description]]
==== Assertion description

It is often valuable to describe the assertion performed, especially for boolean assertions where the default error message just complains that it got `false` instead of `true` (or vice versa).

You can set such a description with `as(String description, Object... args)` but remember to do it before calling the assertion otherwise it is simply ignored as a failing assertion breaks the chained calls.

Example of a failing assertion with a description:
[source,java,indent=0]
----
include::{testDir}/example/core/DescribingAssertionsExample.java[tags=user_guide]
----

The error message starts with the given description in `[]` :

[source,nnm,indent=0]
----
[check Frodo's age] expected:<100> but was:\<33>
----

[[assertj-core-overriding-error-message]]
==== Overriding error message

AssertJ tries its best to give helpful error messages but you always change it with `overridingErrorMessage()` or `withFailMessage()`.

Example with this failing test:
[source,java,indent=0]
----
include::{testDir}/example/core/OverridingErrorMessageExample.java[tags=user_guide]
----

The error message is:

[source,nnm,indent=0]
----
java.lang.AssertionError: should be TolkienCharacter [name=Frodo, age=33, race=HOBBIT]
----


[[assertj-core-incorrect-usage]]
==== Avoiding incorrect usage

There are a few things to keep in mind when using AssertJ to avoid misusing it.

===== Forgetting to call an assertion

The main trap is to pass the object under to test to `assertThat()` and forget to call an assertion afterward.
This misuse can be detected by https://spotbugs.github.io/[SpotBugs] or http://findbugs.sourceforge.net/[Findbugs] thanks to the `@CheckReturnValue` annotation on all `assertThat()` methods.

Here's what it looks like in SpotBugs:
[#img-sunset]
.SpotBugs detecting AssertJ invalid usage
image::spotbugs-invalid-assertj-usage-detection.png[SpotBugs detecting AssertJ invalid usage]

The following examples show incorrect AssertJ API usage to avoid!

[.bad]#Bad#
[source,java,indent=0]
----
// DON'T DO THIS ! It does not assert anything
assertThat(actual.equals(expected));

----

[.good]#Good#
[source,java,indent=0]
----
// DO THIS:
assertThat(actual).isEqualTo(expected);

// OR THIS (less classy but ok):
assertThat(actual.equals(expected)).isTrue();
----

[.bad]#Bad#
[source,java,indent=0]
----
// DON'T DO THIS ! It does not assert anything and passes
assertThat(1 == 2);

----

[.good]#Good#
[source,java,indent=0]
----
// DO THIS: (fails as expected)
assertThat(1).isEqualTo(2);

// OR THIS (less classy but ok):
assertThat(1 == 2).isTrue();
----

===== Calling as() after the assertion

Describing an assertion must be done before calling the assertion otherwise it is ignored as a failing assertion breaks will prevent the call to `as()`.

[.bad]#Bad#
[source,java,indent=0]
----
// DON'T DO THIS ! as/describedAs have no effect after the assertion
assertThat(actual).isEqualTo(expected).as("description");
assertThat(actual).isEqualTo(expected).describedAs("description");
----

[.good]#Good#
[source,java,indent=0]
----
// DO THIS: use as/describedAs before the assertion
assertThat(actual).as("description").isEqualTo(expected);
assertThat(actual).describedAs("description").isEqualTo(expected);
----

===== Calling withFailMessage/overridingErrorMessage after the assertion

Setting an error message must be done before calling the assertion otherwise it is ignored as a failing assertion breaks will prevent the call to `withFailMessage()` / `overridingErrorMessage()`.

[.bad]#Bad#
[source,java,indent=0]
----
// DON'T DO THIS ! overridingErrorMessage/withFailMessage have no effect after the assertion
assertThat(actual).isEqualTo(expected).overridingErrorMessage("custom error message");
assertThat(actual).isEqualTo(expected).withFailMessage("custom error message");
----

[.good]#Good#
[source,java,indent=0]
----
// DO THIS: use overridingErrorMessage/withFailMessage before the assertion
assertThat(actual).overridingErrorMessage("custom error message").isEqualTo(expected);
assertThat(actual).withFailMessage("custom error message").isEqualTo(expected);
----

===== Setting a comparator after the assertion

Setting comparators must be done before calling the assertion otherwise it is ignored as a failing assertion breaks will prevent the call to `usingComparator()` / `usingElementComparator()`.

[.bad]#Bad#
[source,java,indent=0]
----
// DON'T DO THIS ! Comparator is not used
assertThat(actual).isEqualTo(expected).usingComparator(new CustomComparator());
----

[.good]#Good#
[source,java,indent=0]
----
// DO THIS:
assertThat(actual).usingComparator(new CustomComparator()).isEqualTo("a");
----

[[assertj-core-configuration]]
==== Configuring AssertJ

This section describes the different ways to configure AssertJ, either by setting configuration properties individually or globally using the link:#assertj-configuration[`Configuration`] class.

To be effective the configuration changes must be applied before the tests are executed, depending on the scope of the tests this means different things:

* For a single test: change the configuration in the test and revert it in the https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterEach.html[`@AfterEach`] method  (JUnit 5).
* For all tests in a class: change the configuration in the https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/BeforeAll.html[`@BeforeAll`] method and revert the changes in the https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html[`@AfterAll`] method (JUnit 5).
* To change the configuration *before any tests*, you can use these options:
** write a JUnit 5 extension implementing https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/extension/BeforeAllCallback.html[`BeforeAllCallback`].
** register your own `Configuration` subclass and let AssertJ link:#automatic-configuration-discovery[discover it automagically].

===== Configuring single properties

The `Assertions` class provides static methods to change each configuration properties.

[source,java,indent=0]
----
Assertions.setAllowComparingPrivateFields(true);
Assertions.setAllowExtractingPrivateFields(false);
Assertions.setExtractBareNamePropertyMethods(false);
Assertions.setLenientDateParsing(true);
Assertions.setMaxElementsForPrinting(100);
Assertions.setMaxLengthForSingleLineDescription(250);
Assertions.setRemoveAssertJRelatedElementsFromStackTrace(true);
Assertions.useRepresentation(myRepresentation);
Assertions.registerCustomDateFormat(myCustomDateFormat);
----

====== Representation

This property allows you to register a `Representation` to control the way AssertJ formats the different types displayed in the assertion error messages.
Consult the <<assertj-core-representation>> chapter for details.

Defaults to `StandardRepresentation`.

====== AllowComparingPrivateFields

Globally sets whether the use of private fields is allowed for field/property by field/property comparison. Defaults to true.

====== AllowExtractingPrivateFields

Globally sets whether the AssertJ `extracting` capability should be allowed to extract private fields. Defaults to true.

====== ExtractBareNamePropertyMethods

Globally sets whether the AssertJ `extracting` capability considers bare-named property methods like String name(). Defaults to true.

====== LenientDateParsing

Specify whether or not date/time parsing is to be lenient for AssertJ default date formats. With lenient parsing, the parser may use heuristics to interpret inputs that do not precisely match this object's format. With strict parsing, inputs must match this object's format.

====== Custom DateFormat

In addition to the default date formats, you can register some custom ones that AssertJ will use in date assertions (see also `Assertions.registerCustomDateFormat`).

Note that custom date formats take precedence over default ones.

====== MaxElementsForPrinting

In error messages, sets the threshold for how many elements from one iterable/array/map will be included in the in the description. Defaults to 1000.

The point of this property is to avoid printing iterable/array/map with too many elements in error messages.

====== MaxLengthForSingleLineDescription

In error messages, sets the threshold when iterable/array formatting will be on one line (if their String description
is less than this parameter) or it will be formatted with one element per line. Defaults to 80.

Example:

[source,java,indent=0]
----
String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice");
----

this array is formatted on one line as its length < 80:

[source,java,indent=0]
----
["A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice"]
----

Whereas this array ...

[source,java,indent=0]
----
String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice", "Guards! Guards! (Discworld)");
----

\... is formatted on multiple lines with one element per line:

[source,java,indent=0]
----

["A Game of Thrones",
 "The Lord of the Rings",
 "Assassin's Apprentice",
 "Guards! Guards! (Discworld)"]
----

====== RemoveAssertJRelatedElementsFromStackTrace

Sets whether the elements related to AssertJ are removed from assertion errors stack trace. Defaults to true.


[[assertj-configuration]]
===== AssertJ Configuration

Since 3.13.0, AssertJ exposes a `org.assertj.core.configuration.Configuration` object providing access to all AssertJ globally configurable properties.

You can create an instance of `org.assertj.core.configuration.Configuration` and change indivual properties through setters or create your own custom configuration by inheriting from it and overriding the methods to change the default behavior as in the `CustomConfiguration` example below.

IMPORTANT: Your configuration will be effective once you call `Configuration.apply()` or `Configuration.applyAndDisplay()`.

Example:

[source,java,indent=0]
----
Configuration configuration = new Configuration();

configuration.setBareNamePropertyExtraction(false);
configuration.setComparingPrivateFields(false);
configuration.setExtractingPrivateFields(false);
configuration.setLenientDateParsing(true);
configuration.setMaxElementsForPrinting(1001);
configuration.setMaxLengthForSingleLineDescription(81);
configuration.setRemoveAssertJRelatedElementsFromStackTrace(false);

// don't forget to apply it!
configuration.applyAndDisplay();
----

Printing the above configuration produces the following output:

[source,plaintext,indent=0]
----
Applying configuration org.assertj.core.configuration.Configuration
- representation .................................. = BinaryRepresentation
- comparingPrivateFieldsEnabled ................... = false
- extractingPrivateFieldsEnabled .................. = true
- bareNamePropertyExtractionEnabled ............... = false
- lenientDateParsingEnabled ....................... = true
- additionnal date formats ........................ = [yyyy_MM_dd, yyyy|MM|dd]
- maxLengthForSingleLineDescription ............... = 150
- maxElementsForPrinting .......................... = 2000
- removeAssertJRelatedElementsFromStackTraceEnabled = true
----


[[automatic-configuration-discovery]]
===== Automagic configuration discovery

This section describes a way to register an AssertJ `Configuration` without using any test framework hooks like `BeforeAllCallback`.

Follow the steps below to register your `Configuration` as an SPI:

* Create your own configuration inheriting from `org.assertj.core.configuration.Configuration`
* Create a file named `org.assertj.core.configuration.Configuration` in a `META-INF/services` directory
* Make sure `META-INF/services/` is in the runtime classpath, usually putting it in `src/test/resources` will do.
* Put the fully qualified class name of your `Configuration` in `services/org.assertj.core.configuration.Configuration`.

This is all you have to do, AssertJ will pick up the `Configuration` automatically and display it at the first interaction with AssertJ.

Here's an example of a custom configuration class:

[source,java,indent=0]
----
include::{testDir}/example/core/CustomConfiguration.java[]
----

With this custom configuration, the content of `META-INF/services/org.assertj.core.configuration.Configuration` must be:
[source,java,indent=0]
----
example.core.CustomConfiguration
----

Printing the  `CustomConfiguration` shows:
[source,plaintext,indent=0]
----
Applying configuration example.core.CustomConfiguration
- representation .................................. = BinaryRepresentation
- comparingPrivateFieldsEnabled ................... = false
- extractingPrivateFieldsEnabled .................. = true
- bareNamePropertyExtractionEnabled ............... = false
- lenientDateParsingEnabled ....................... = true
- additionnal date formats ........................ = [yyyy_MM_dd, yyyy|MM|dd]
- maxLengthForSingleLineDescription ............... = 150
- maxElementsForPrinting .......................... = 2000
- removeAssertJRelatedElementsFromStackTraceEnabled = true
----



[[assertj-core-representation]]
==== Controlling type formatting

Assertions error messages use a `Representation` to format the different types involved. There are multiple ways of registering a custom `Representation` for assertions:

* Changing the default global `Representation` by calling `Assertions.useRepresentation(myRepresentation)` - see <<Changing the default global scope custom representation>>
* Changing the `Representation` per assertion with `assertThat(actual).withRepresentation(myRepresentation)` - see <<Per assertion scope custom representation>>
* Globally registering a `Configuration` that specifies the `Representation` to use - see link:#assertj-core-configuration[AssertJ global configuration].

Let's go over these different options with a custom `Representation`.

[[assertj-core-custom-representation]]
===== Creating a custom Representation

An example of a custom `Representation`:
[source,java,indent=0]
----
// dummy class
private class Example {}

public class CustomRepresentation extends StandardRepresentation { // <1>

  // override fallbackToStringOf to handle Example formatting
  @Override
  public String fallbackToStringOf(Object o) { // <2>
    if (o instanceof Example) return "Example";
    // fallback to default formatting.
    return super.fallbackToStringOf(o);
  }

  // override a predefined type formatting : String
  @Override
  protected String toStringOf(String str) { // <3>
    return "$" + str + "$";
  }
}
----
<1> Extends `org.assertj.core.presentation.StandardRepresentation` to get AssertJ default representation.
<2> Override `fallbackToStringOf` and handle your specific types before falling back to the default formatting.
<3> Change a predefined type formatting by overriding the `toStringOf` method that takes it as a parameter.

Let's see the above custom representation in action when representing `Example` or `String` instances.

This assertion fails ...
[source,java,indent=0]
----
assertThat(new Example()).isNull();
----
...with the following error:
[source,java,indent=0]
----
expected:<[null]> but was:<[Example]>
----

This one fails ...
[source,java,indent=0]
----
// this one fails ...
assertThat("foo").startsWith("bar");
----
...with the following error:
[source,java,indent=0]
----
Expecting:
  <$foo$>
to start with:
  <$bar$>
----

[[assertj-core-custom-representation-global-scope-change]]
===== Changing the default global scope custom representation

You only have to register `CustomRepresentation` once but need to do it before executing any tests, for the tests executed before that, AssertJ will use the default representation.

[source,java,indent=0]
----
// to call before executing tests
Assertions.useRepresentation(new CustomRepresentation());
----

Consider writing a JUnit 5 extension implementing https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/extension/BeforeAllCallback.html[`BeforeAllCallback`] to make sure the representation is set once for all before any test is executed.

[[assertj-core-custom-representation-per-assertion-scope]]
===== Per assertion scope custom representation

Follow this approach if you want to use a specific representation for a single assertion only.

Example with the failing assertions used before:
[source,java,indent=0]
----
Representation customRepresentation = new CustomRepresentation();

// this assertion fails ...
assertThat(new Example()).withRepresentation(customRepresentation)
                         .isNull();

assertThat("foo").withRepresentation(customRepresentation)
                 .startsWith("bar");
----


[[assertj-core-common-assertions]]
==== Common assertions

This section describes the assertions common to all types.

[[assertj-core-object-assertions]]
==== Object assertions (TODO)

TODO

[[assertj-string-object-assertions]]
==== String/CharSequence assertions

This section describes all the available assertions for `CharSequence` (including `String`, `StringBuilder`, `StringBuffer`, ...):

The javadoc for `CharSequence` assertions is available https://www.javadoc.io/static/org.assertj/assertj-core/{assertj-core-version}/org/assertj/core/api/AbstractCharSequenceAssert.html#method.summary[here].


[[assertj-core-iterable-assertions]]
==== Iterable/Collection/array assertions (WIP)

TODO

[[assertj-core-array-assertions]]
===== byte[] specific assertions

This section covers assertions to byte array.

[[assertj-core-exception-assertions]]
==== Exception assertions

This chapter answers the question: how to assert that an exception has been thrown and check that it is the expected one?

If you use java 8 or later versions, check the link:#assertj-core-exception-assertions-java-8[Java 8 section] which heavily uses lambdas.
If you use java 7, check the link:#assertj-core-exception-assertions-java-7[Java 7 section].

All the available assertions are described in the link:#assertj-core-exception-assertions-reference[throwable assertions reference section].

In this chapter the term `exception` is used interchangeably with `throwable`.

[[assertj-core-exception-assertions-java-8]]
===== With Java 8 (AssertJ 3.x)

Testing assertions in Java 8 is elegant, thanks to lambdas! AssertJ provides different style options:

- link:#assertj-core-exception-assertions-bdd-style[`catchThrowable(ThrowingCallable)`]
- link:#assertj-core-exception-assertions-bdd-strongly-typed-style[`catchThrowableOfType(ThrowingCallable)`]
- link:#assertj-core-exception-assertions-assertThatThrownBy[`assertThatThrownBy(ThrowingCallable)`]
- link:#assertj-core-exception-assertions-assertThatExceptionOfType[`assertThatExceptionOfType(exception class)`]
- link:#assertj-core-exception-assertions-no-exception[Testing that no exception is thrown]

where `ThrowingCallable` is a functional interface which can be expressed as a lambda.

[[assertj-core-exception-assertions-bdd-style]]
====== BDD style

BDD aficionados can separate _WHEN_ and _THEN_ steps by using `catchThrowable(ThrowingCallable)` to capture the `Throwable` and then perform assertions.

Example:
[source,java]
----
@Test
public void bdd_exception_assertion_example() {
   // GIVEN
   String[] names = { "Pier ", "Pol", "Jak" };
   // WHEN
   Throwable thrown = catchThrowable(() -> System.out.println(names[9]));
   // THEN
   assertThat(thrown).isInstanceOf(ArrayIndexOutOfBoundsException.class)
                     .hasMessageContaining("9");
}
----

[[assertj-core-exception-assertions-bdd-strongly-typed-style]]
====== BDD style on specific Throwable type

This is a variation of `catchThrowable` where the caught exception type is specified, allowing to check the custom exception fields/properties.

Example:
[source,java]
----
class TextException extends Exception {
   int line;
   int column;

   public TextException(String msg, int line, int column) {
     super(msg);
     this.line = line;
     this.column = column;
   }
 }

 TextException textException = catchThrowableOfType(() -> { throw new TextException("boom!", 1, 5); },
                                                    TextException.class);
 // assertions succeed
 assertThat(textException).hasMessageContaining("boom");
 assertThat(textException.line).isEqualTo(1);
 assertThat(textException.column).isEqualTo(5);

 // succeeds as catchThrowableOfType returns null when the code does not thrown any exceptions
 assertThat(catchThrowableOfType(() -> {}, Exception.class)).isNull();

 // fails as TextException is not a RuntimeException
 catchThrowableOfType(() -> { throw new TextException("boom!", 1, 5); }, RuntimeException.class);
----

[[assertj-core-exception-assertions-assertThatThrownBy]]
====== Exception testing with assertThatThrownBy

Starts with `assertThatThrownBy(ThrowingCallable)` to capture and then assert on the thrown `Throwable`.

Note that if the provided `ThrowingCallable` does not raise an exception, an assertion error is immediately thrown.

Example:
[source,java]
----
@Test
public void exception_assertion_example() {
   assertThatThrownBy(() -> { throw new Exception("boom!"); }).isInstanceOf(Exception.class)
                                                              .hasMessageContaining("boom");
}
----

[[assertj-core-exception-assertions-assertThatExceptionOfType]]
====== Exception testing with assertThatExceptionOfType

`assertThatExceptionOfType` is an alternative syntax that some people find more natural.

Note that if the code under test `ThrowingCallable` does not raise an exception, an assertion error is immediately thrown.

[source,java]
----
@Test
public void exception_assertion_example() {
   assertThatExceptionOfType(IOException.class).isThrownBy(() -> { throw new IOException("boom!"); })
                                               .withMessage("%s!", "boom")
                                               .withMessageContaining("boom")
                                               .withNoCause();
}
----

This latter syntax has been enriched for common exceptions:

* `assertThatNullPointerException`
* `assertThatIllegalArgumentException`
* `assertThatIllegalStateException`
* `assertThatIOException`

The previous test can be rewritten as:
[source,java]
----
@Test
public void exception_assertion_example() {
   assertThatIOException().isThrownBy(() -> { throw new IOException("boom!"); })
                          .withMessage("%s!", "boom")
                          .withMessageContaining("boom")
                          .withNoCause();
}
----

[[assertj-core-exception-assertions-no-exception]]
====== Testing that no exception is thrown

You can test that a piece of code does not throw any exception with:
[source,java]
----
assertThatCode(() -> {
  // code that should NOT throw an exception
  ...
}).doesNotThrowAnyException();
----

[[assertj-core-exception-assertions-reference]]
===== Throwable reference assertions reference (WIP)

This section describes all the available assertions for throwables:

- link:#assertj-core-throwable-assertions-hasMessage[Checking the throwable message]
- link:#assertj-core-throwable-cause-and-root-cause-assertions[Checking the throwable's cause and root cause]

The javadoc for throwable assertions is available https://www.javadoc.io/static/org.assertj/assertj-core/{assertj-core-version}/org/assertj/core/api/AbstractThrowableAssert.html#method.summary[here].

[[assertj-core-throwable-assertions-hasMessage]]
====== Checking the throwable message

There are two ways to check the exception message: `hasMessage(String message)` and `hasMessage(String message, Object... parameters)`, the latter allows you to build the expected message as https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true#format-java.lang.String-java.lang.Object...-[String.format].

Examples:
[source,java]
----
Throwable invalidArgException = new IllegalArgumentException("foo is not a valid input");
Throwable throwable = new Throwable(invalidArgException);

// This assertion succeeds:
assertThat(throwable).hasMessage("foo is not a valid input");
assertThat(throwable).hasMessage("%s is not a valid input", "foo");

// These assertions fail:
assertThat(throwable).hasMessage("bar is not a valid input");
assertThat(throwable).hasMessage("%s is not a valid input", "bar");
----

[[assertj-core-throwable-cause-and-root-cause-assertions]]
====== Checking cause and root cause

It is possible to assert on the cause and/or root cause properties of an exception by using `getCause()` and `getRootCause()`. +
These methods change the object under test from the current throwable to its cause or root cause.

Examples:
[source,java]
----
NullPointerException rootCause = new NullPointerException("root cause message");
IllegalArgumentException cause = new IllegalArgumentException("cause message", rootCause);
Throwable throwable = new Throwable("top level", cause);

// These assertions succeed:
assertThat(throwable).hasMessage("top level")
                     .getCause() 
                     // all further chaining is against throwable's cause
                     .hasMessage("cause message");

assertThat(throwable).hasMessage("top level")
                     .getRootCause()
                     // all further chaining is against throwable's root cause
                     .hasMessage("root cause message");

// This assertion fails:
assertThat(throwable).hasMessage("top level")
                     .getCause()
                     .hasMessage("some other message");
----

The same is also possible using `assertThatExceptionOfType` as in the following example checking that the throwable is a `RuntimeException` with "boom!" for its cause message.

[source,java]
----
assertThatExceptionOfType(RuntimeException.class)
         .isThrownBy(() -> { throw new RuntimeException(new IllegalArgumentException("boom!")); })
         .havingCause()
         .withMessage("boom!");
----

Similar example with `havingRootCause`:

[source,java]
----
assertThatExceptionOfType(RuntimeException.class)
         .isThrownBy(() -> { throw new RuntimeException(new IllegalArgumentException(new NullPointerException("root error"))); })
         .havingRootCause()
         .withMessage("root error");
----

[[assertj-core-exception-assertions-java-7]]
===== With Java 7 (AssertJ 2.x)

Asserting on exceptions is not as nice compared to the Java 8 way, this is how you would do it in AssertJ 2.x :

. Put the code that should throw the exception in a try-catch.
. Call fail method immediately after, so that the test fails if the exception is not thrown.
. Make assertions on the caught exception.

Note that `fail` method can be statically imported from `Assertions` class.

[source,java]
----
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;
import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
// ... code omitted for brevity

assertThat(fellowshipOfTheRing).hasSize(9);

// here's the typical pattern to use Fail :
try {
  fellowshipOfTheRing.get(9); // argggl !
  // we should not arrive here => use fail to expresses that
  // if IndexOutOfBoundsException was not thrown, test would fail the specified message
  fail("IndexOutOfBoundsException expected because fellowshipOfTheRing has only 9 elements");
} catch (IndexOutOfBoundsException e) {
  assertThat(e).hasMessage("Index: 9, Size: 9");
}

// Warning : don't catch Throwable as it would also catch the AssertionError thrown by fail method

// another way to do the same thing
try {
  fellowshipOfTheRing.get(9); // argggl !
  // if IndexOutOfBoundsException was not thrown, test would fail with message :
  // "Expected IndexOutOfBoundsException to be thrown"
  failBecauseExceptionWasNotThrown(IndexOutOfBoundsException.class);
} catch (IndexOutOfBoundsException e) {
  assertThat(e).hasMessage("Index: 9, Size: 9");
}
----

[[assertj-core-recursive-comparison]]
==== Field by field recursive comparison

Since 3.12.0 AssertJ Core provides a new fluent recursive comparison API for `Object` assertions, it is meant to replace `isEqualToComparingFieldByFieldRecursively` with more capabilities including:

* link:#assertj-core-recursive-comparison-strict[Choosing a strict or lenient recursive comparison]
* link:#assertj-core-recursive-comparison-ignoring-fields[Ignoring fields in the comparison]
* link:#assertj-core-recursive-comparison-comparators[Specifying comparators to use in the comparison]
* link:#assertj-core-recursive-comparison-ignoring-equals[Force recursive comparison on classes that have redefined `equals`]
* link:#assertj-core-recursive-comparison-ignoring-all-expected-null-fields[Ignoring all expected null fields]
* link:#assertj-core-recursive-comparison-ignoring-all-actual-empty-optional-fields[Ignoring all actual empty optional fields].

The recursive comparison mode starts after calling `usingRecursiveComparison()`.
By default it uses `equals` methods of classes that have overriden it, this behavior can be changed forcing recursive comparison on these classes (link:#assertj-core-recursive-comparison-ignoring-equals[see this section]).

Here's a simple example to give an idea of what it can do:

[source,java,indent=0]
----
 public class Person {
   String name;
   double height;
   Home home = new Home();
 }

 public class Home {
   Address address = new Address();
   Date ownedSince;
 }

 public static class Address {
   int number;
   String street;
 }

 Person sherlock = new Person("Sherlock", 1.80);
 sherlock.home.ownedSince = new Date(123);
 sherlock.home.address.street = "Baker Street";
 sherlock.home.address.number = 221;

 Person sherlock2 = new Person("Sherlock", 1.80);
 sherlock2.home.ownedSince = new Date(123);
 sherlock2.home.address.street = "Baker Street";
 sherlock2.home.address.number = 221;

 // assertion succeeds as the data of both objects are the same.
 assertThat(sherlock).usingRecursiveComparison()
                     .isEqualTo(sherlock2);

 // assertion fails as Person equals only compares references.
 assertThat(sherlock).isEqualTo(sherlock2);
----

The comparison is *not symmetrical* since it is *limited to actual's fields*, the algorithm gather actual's fields and then compare them to the corresponding expected's fields. It is then possible for the expected object to have more fields than actual which can be handy when comparing a base type to a subtype with additional fields.

[[assertj-core-recursive-comparison-strict]]
===== Strict or lenient comparison

By default the objects to compare can be of different types but must have the same properties/fields. For example if object under test has a `work` field of type `Address`, the expected object to compare the object under test to must also have one but it can of a different type like `AddressDto`.

It is possible to enforce strict type checking by calling `withStrictTypeChecking()` and make the comparison fail whenever the compared objects or their fields are not compatible. Compatible means that the expected object/field types are the same or a subtype of actual/field types, for example if actual is an `Animal` and expected a `Dog`, they will be compared field by field in strict type checking mode.

[source,java,indent=0]
----
public class Person {
  String name;
  double height;
  Person bestFriend;
}

Person sherlock = new Person("Sherlock", 1.80);
sherlock.bestFriend = new Person("Watson", 1.70);

Person sherlockClone = new Person("Sherlock", 1.80);
sherlockClone.bestFriend = new Person("Watson", 1.70);

// assertion succeeds as sherlock and sherlockClone have the same data and types
assertThat(sherlock).usingRecursiveComparison()
                    .withStrictTypeChecking()
                    .isEqualTo(sherlockClone);

// Let's now define a data structure similar to Person

public class PersonDTO {
  String name;
  double height;
  PersonDTO bestFriend;
}

PersonDTO sherlockDto = new PersonDTO("Sherlock", 1.80);
sherlockDto.bestFriend = new PersonDTO("Watson", 1.70);

// assertion fails as Person and PersonDTO are not compatible even though they have the same data
assertThat(sherlock).usingRecursiveComparison()
                    .withStrictTypeChecking()
                    .isEqualTo(noName);

// Let's define a subclass of Person

public class Detective extends Person {
  boolean busy;
}

Detective detectiveSherlock = new Detective("Sherlock", 1.80);
detectiveSherlock.bestFriend = new Person("Watson", 1.70);
detectiveSherlock.busy = true;

// assertion succeeds as Detective inherits from Person and
// only Person's fields are included into the comparison.
assertThat(sherlock).usingRecursiveComparison()
                    .withStrictTypeChecking()
                    .isEqualTo(detectiveSherlock);
----

[[assertj-core-recursive-comparison-ignoring-fields]]
===== Ignoring fields in the comparison

It is possible to ignore fields of the object under test in the comparison, this is can be useful when a field has a generated value (like the current time) or is simply not relevant to compare.

There are a few ways to specify the fields to ignore:

* directly with `ignoringFields(String... fieldsToIgnore)`
* by regexes with `ignoringFieldsMatchingRegexes(String... regexes)`
* by types with `ignoringFieldsOfTypes(Class... typesToIgnore)`

Nested fields can be specified like this: `home.address.street`

It is also possible to ignore the the object under test with `ignoringActualNullFields()`.

Examples

[source,java,indent=0]
----
Person sherlock = new Person("Sherlock", 1.80);
sherlock.home.address.street = "Baker Street";
sherlock.home.address.number = 221;

// strangely moriarty and sherlock have the same height!
Person moriarty = new Person("Moriarty", 1.80);
moriarty.home.address.street = "Crime Street";
moriarty.home.address.number = 221;

// assertion succeeds as name and home.address.street fields are ignored in the comparison
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringFields("name", "home.address.street")
                    .isEqualTo(moriarty);

// assertion succeeds as once a field is ignored, its subfields are too
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringFields("name", "home")
                    .isEqualTo(moriarty);

// ignoring fields matching regexes: name and home match .*me
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringFieldsMatchingRegexes(".*me")
                    .isEqualTo(moriarty);

// ignoring null fields example:
sherlock.name = null;
sherlock.home.address.street = null;
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringActualNullFields()
                    .isEqualTo(moriarty);

// ignore height and address fields by type: 
Person tallSherlock = new Person("sherlock", 2.10);
tallSherlock.home.address.street = "Long Baker Street";
tallSherlock.home.address.number = 222;
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringFieldsOfTypes(double.class, Address.class)
                    .isEqualTo(tallSherlock);
----

[[assertj-core-recursive-comparison-ignoring-equals]]
===== Ignoring overridden equals

By default the recursive comparison uses overridden `equals` methods to compare fields, it is possible to change that behavior and force a recursive comparison by calling:

* `ignoringOverriddenEqualsForTypes(Class...)` Any fields of these classes are compared recursively
* `ignoringOverriddenEqualsForFields(String...)` Any given fields are compared recursively
* `ignoringOverriddenEqualsForFieldsMatchingRegexes(String...)` Any fields matching one of these regexes are compared recursively
* `ignoringAllOverriddenEquals()` except for java types, all fields are compared field by field recursively

Example:

[source,java,indent=0]
----
 public class Person {
   String name;
   double height;
   Home home = new Home();
 }

 public class Home {
   Address address = new Address();
 }

 public static class Address {
   int number;
   String street;

   // only compares number, ouch!
   @Override
   public boolean equals(final Object other) {
     if (!(other instanceof Address)) return false;
     Address castOther = (Address) other;
     return Objects.equals(number, castOther.number);
   }
 }

 Person sherlock = new Person("Sherlock", 1.80);
 sherlock.home.address.street = "Baker Street";
 sherlock.home.address.number = 221;

 Person sherlock2 = new Person("Sherlock", 1.80);
 sherlock2.home.address.street = "Butcher Street";
 sherlock2.home.address.number = 221;

 // assertion succeeds but that's not what we expected since the home.address.street fields differ
 // but the equals implementation in Address does not compare them.
 assertThat(sherlock).usingRecursiveComparison()
                     .isEqualTo(sherlock2);

 // to avoid the previous issue, we force a recursive comparison on the Address type
 // now this assertion fails as expected since the home.address.street fields differ.
 assertThat(sherlock).usingRecursiveComparison()
                     .ignoringOverriddenEqualsForTypes(Address.class)
                     .isEqualTo(sherlock2);
----

[[assertj-core-recursive-comparison-ignoring-all-expected-null-fields]]
===== Ignoring all expected null fields

By using `ignoringExpectedNullFields()` the recursive comparison will exclude from the comparison any null fields in the expected object. + 
One use case for that is when the object under test have fields with values hard to predict (id, timestamp, ...),  with this feature you simply build the expected object with null values values for these fields and they won't be compared.

Example:

[source,java,indent=0]
----
public class Person {  
  String name;
  double height;
  Home home = new Home();
}
public class Home {
  Address address = new Address();
}
public static class Address {
  int number;
  String street;
}

Person sherlock = new Person("Sherlock", 1.80);
sherlock.home.address.street = "Baker Street";
sherlock.home.address.number = 221;

Person noName = new Person(null, 1.80);
noName.home.address.street = null;
noName.home.address.number = 221;

// assertion succeeds as name and home.address.street fields are ignored in the comparison
assertThat(sherlock).usingRecursiveComparison()
                    .ignoringExpectedNullFields()
                    .isEqualTo(noName);

// assertion fails as name and home.address.street fields are populated for sherlock but not for noName.
assertThat(noName).usingRecursiveComparison()
                  .ignoringExpectedNullFields()
                  .isEqualTo(sherlock);
----

[[assertj-core-recursive-comparison-ignoring-all-actual-empty-optional-fields]]
===== Ignoring all actual empty optional fields

`ignoringActualEmptyOptionalFields()` makes the recursive comparison to ignore all actual empty optional fields (including `Optional`, `OptionalInt`, `OptionalLong` and `OptionalDouble`). + 
Note that the expected object empty optional fields are not ignored, this only applies to actual's fields. 

[source,java,indent=0]
----
 public class Person {
   String name;
   OptionalInt age;
   OptionalLong id;
   OptionalDouble height;
   Home home = new Home();
 }

 public class Home {
   String address;
   Optional<String> phone;
 }

 Person homerWithoutDetails = new Person("Homer Simpson");
 homerWithoutDetails.home.address.street = "Evergreen Terrace";
 homerWithoutDetails.home.address.number = 742;
 homerWithoutDetails.home.phone = Optional.empty();
 homerWithoutDetails.age = OptionalInt.empty();
 homerWithoutDetails.id = OptionalLong.empty();
 homerWithoutDetails.height = OptionalDouble.empty();

 Person homerWithDetails = new Person("Homer Simpson");
 homerWithDetails.home.address.street = "Evergreen Terrace";
 homerWithDetails.home.address.number = 742;
 homerWithDetails.home.phone = Optional.of("(939) 555-0113");
 homerWithDetails.age = OptionalInt.of(39);
 homerWithDetails.id = OptionalLong.of(123456);
 homerWithDetails.height = OptionalDouble.of(1.83);

 // assertion succeeds as phone is ignored in the comparison
 assertThat(homerWithoutDetails).usingRecursiveComparison()
                                .ignoringActualEmptyOptionalFields()
                                .isEqualTo(homerWithDetails);

 // assertion fails as phone, age, id and height are not ignored and are populated for homerWithDetails but not for homerWithoutDetails.
 assertThat(homerWithDetails).usingRecursiveComparison()
                             .ignoringActualEmptyOptionalFields()
                             .isEqualTo(homerWithoutDetails);
----

[[assertj-core-recursive-comparison-comparators]]
===== Comparators used in the comparison

By default floats are compared with a precision of 1.0E-6 and doubles with 1.0E-15.

You can specify a custom comparator per (nested) fields or type with the methods below (but before calling `isEqualTo` otherwise this has no effect!):

* `withComparatorForFields(Comparator, String...)` for one or multiple fields
* `withComparatorForType(Comparator, Class)` for a given type

Examples:

[source,java,indent=0]
----
public class TolkienCharacter {
  String name;
  double height;
}

TolkienCharacter frodo = new TolkienCharacter("Frodo", 1.2);
TolkienCharacter tallerFrodo = new TolkienCharacter("Frodo", 1.3);
TolkienCharacter reallyTallFrodo = new TolkienCharacter("Frodo", 1.9);

Comparator<Double> closeEnough = (d1, d2) -> Math.abs(d1 - d2) <= 0.5 ? 0 : 1;

// assertion succeeds
assertThat(frodo).usingRecursiveComparison()
                 .withComparatorForFields(closeEnough, "height")
                 .isEqualTo(tallerFrodo);

assertThat(frodo).usingRecursiveComparison()
                 .withComparatorForType(closeEnough, Double.class)
                 .isEqualTo(tallerFrodo);


// assertions fail
assertThat(frodo).usingRecursiveComparison()
                 .withComparatorForFields(closeEnough, "height")
                 .isEqualTo(reallyTallFrodo);

assertThat(frodo).usingRecursiveComparison()
                 .withComparatorForType(closeEnough, Double.class)
                 .isEqualTo(reallyTallFrodo);
----



[[assertj-core-soft-assertions]]
==== Soft assertions

With soft assertions AssertJ collects all assertion errors instead of stopping at the first one.

TIP: This is especially useful for long tests like end to end tests as we can fix all reported errors at once and avoid multiple failing runs.

Since soft assertions don't fail at the first error, you need to tell AssertJ when to report the captured assertion errors, there are different ways of doing so:

* Calling `assertAll()` (basic approach)
* Using a link:#assertj-core-junit4-soft-assertions[JUnit 4 rule] that takes care of calling `assertAll()` after each tests
* Using a link:#assertj-core-junit5-soft-assertions[JUnit 5 extension] that takes care of calling `assertAll()` after each tests
* Using a link:#assertj-core-closeable-soft-assertions[`AutoCloseableSoftAssertions`]
* Using link:#assertj-core-assertSoftly-assertions[`assertSoftly` static method]
* 

Soft assertions comes with a link:#assertj-core-bdd-soft-assertions[BDD flavor] where `assertThat` is replaced by `then`.

If you have created your own custom Soft assertions it is possible to link:#assertj-core-soft-assertions-combining[combine them all in a single soft assertions entry point].

Let's see first how to use soft assertions *requiring an explicit call to `assertAll()`*, the other approaches that don't require this explicitit call are described in the subsequent sections.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/SoftAssertionsExample.java[tags=basic-soft-assertions]
----
<1> Build a `SoftAssertions` instance to record all assertion errors
<2> Use `softly.assertThat` instead of the usual `assertThat` methods
<3> *Don't forget to call `assertAll()` to report all assertion errors!*

The previous test fails with the message below reporting all the errors:

[source, text]
----
Multiple Failures (3 failures)
-- failure 1 --
[great authors]
Expecting:
 <"George Martin">
to be equal to:
 <"JRR Tolkien">
but was not.
-- failure 2 --
[response to Everything]
Expecting:
 \<42>
to be greater than:
 \<100>
-- failure 3 --
Expecting:
 <"gandalf">
to be equal to:
 <"sauron">
but was not.
----

[[assertj-core-bdd-soft-assertions]]
===== BDD Soft assertions

BDD aficionados can use BDD soft assertions where `assertThat` is replaced by `then`.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/BDDSoftAssertionsExample.java[tags=basic-bdd-soft-assertions]
----

There are BDD soft assertions versions for the different soft assertions approaches:

* `AutoCloseableBDDSoftAssertions`
* Using `JUnitBDDSoftAssertions` that takes care of calling `assertAll()` after each tests
* Using a JUnit 5 extension that takes care of calling `assertAll()` after each tests

[[assertj-core-junit4-soft-assertions]]
===== JUnit 4 Soft assertions rule

The JUnit rule provided by AssertJ takes care of calling `assertAll()` at the end of each tests.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/JUnit4SoftAssertionsExample.java[tags=junit4-soft-assertions]
----

In a similar way you can use `JUnitBDDSoftAssertions`  where `assertThat` is replaced by `then`:
[source,java,indent=0]
----
include::{testDir}/example/core/JUnit4BDDSoftAssertionsExample.java[tags=junit4-bdd-soft-assertions]
----

[[assertj-core-junit5-soft-assertions]]
===== JUnit 5 Soft assertions extension

Since 3.13.0 AssertJ provides `SoftAssertionsExtension` a JUnit 5 extension that takes care of two things:

* Injecting a `SoftAssertions` or `BDDSoftAssertions` parameter in each test methods
* Calling `assertAll()` at the end of each tests

Moreover in 3.16.0 `SoftAssertionsExtension` is now able to inject any custom soft assertions as long as it implements `SoftAssertionsProvider`. +
See the end of link:#assertj-core-junit5-soft-assertions-custom-injection[combining soft assertions entry points] section for an example.

The term "test method" refers to any method annotated with `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` or `@TestTemplate`.
Notably, the extension is compatible with link:https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests[parameterized tests], the parameterized arguments must come first and the soft assertions argument last.

IMPORTANT: `JUnitJupiterSoftAssertions` and `JUnitJupiterBDDSoftAssertions` are now deprecated in favor of `SoftAssertionsExtension`.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/JUnit5SoftAssertionsExample.java[tags=junit5-soft-assertions]
----


[[assertj-core-closeable-soft-assertions]]
===== Auto Closeable Soft assertions

As `AutoCloseableSoftAssertions` implements `AutoCloseable#close()` by calling `assertAll()`, when used in a try-with-resources block `assertAll()` is called automatically before exiting the block.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/AutoCloseableSoftAssertionsExample.java[tags=closeable-soft-assertions]
----

In a similar way you can use `AutoCloseableBDDSoftAssertions`  where `assertThat` is replaced by `then`:
[source,java,indent=0]
----
include::{testDir}/example/core/AutoCloseableBDDSoftAssertionsExample.java[tags=closeable-bdd-soft-assertions]
----

[[assertj-core-assertSoftly-assertions]]
===== Soft assertions with `assertSoftly`

The `assertSoftly` static method takes care of calling `assertAll()` before exiting.

Example:
[source,java,indent=0]
----
include::{testDir}/example/core/SoftAssertionsExample.java[tags=assertSoftly-soft-assertions]
----

[[assertj-core-soft-assertions-combining]]
===== Combining soft assertions entry points

Since the 3.16.0 version AssertJ provides a way to combine standard soft assertions with custom ones in a single entry point. 

Let's assume we have written an entry point for `TolkienCharacter` soft assertions so that we can write assertions like:

[source,java,indent=0]
----
TolkienSoftAssertions softly = new TolkienSoftAssertions();
softly.assertThat(frodo).hasRace(HOBBIT)
                        .hasName("Frodo");
----
If we want to check standard soft assertions we could make `TolkienSoftAssertions` inherit `SoftAssertions` but if we want to have `GoTSoftAssertions` too then we are stuck as Java does not allow multiple inheritance.

The 3.16.0 release introduced the `SoftAssertionsProvider` interface to define soft assertions entry points.

[.underline]#Step 1# +
The first step consists in extending this interface to expose as many custom entry points as you need. + 
The typical custom `SoftAssertionsProvider` interface exposes default `assertThat` methods, as shown below:

[source,java,indent=0]
----
public interface TolkienSoftAssertionsProvider extends SoftAssertionsProvider {
  // custom assertions
  default TolkienCharacterAssert assertThat(TolkienCharacter actual) {
    return proxy(TolkienCharacterAssert.class, TolkienCharacter.class, actual);
  }
}

// let's add a Game of Thrones entry point
public interface GoTSoftAssertionsProvider extends SoftAssertionsProvider {
  // custom assertions
  default GoTCharacterAssert assertThat(GoTCharacter actual) {
    return proxy(GoTCharacterAssert.class, GoTCharacter.class, actual);
  }
}
----

[.underline]#Step 2# +
In order to get a concrete entry point exposing all custom entry points, create a class implementing all custom `SoftAssertionsProvider` and extending `AbstractSoftAssertions`.
`AbstractSoftAssertions` provides the core internal implementation to collect all errors from the different implemented entry points (it also implements `SoftAssertionsProvider`). 

To get standard soft assertions, inherit from `SoftAssertions` instead of `AbstractSoftAssertions` (or `BddSoftAssertions` to get the BDD flavor).

Let's define our concrete entry points implementing both `TolkienSoftAssertionsProvider` and `GoTSoftAssertionsProvider`:
[source,java,indent=0]
----
// we extend SoftAssertions to get standard soft assertions
public class FantasySoftAssertions extends SoftAssertions 
                                   implements TolkienSoftAssertionsProvider, GoTSoftAssertionsProvider {

  // we can even add more assertions here
  public HumanAssert assertThat(Human actual) {
    return proxy(HumanAssert.class, Human.class, actual);
  }
}
----

[.underline]#Step 3# +
The last step is to use `FantasySoftAssertions`:
[source,java,indent=0]
----
FantasySoftAssertions softly = new FantasySoftAssertions();

// custom TolkienCharacter assertions
softly.assertThat(frodo).hasRace(HOBBIT);

// custom GoTCharacter assertions
softly.assertThat(nedStark).isDead();

// standard assertions
softly.assertThat("Games of Thrones").startsWith("Games")
                                     .endsWith("Thrones");
// verify assertions
softly.assertAll();
----

[[assertj-core-junit5-soft-assertions-custom-injection]]
[.underline]#Optional step: use `SoftAssertionsExtension`# +

JUnit 5 `SoftAssertionsExtension` calls `softly.assertAll()` after each test so that we don't have to do it manually. +
Since 3.16.0 it is capable of injecting any `SoftAssertionsProvider`, we can then inject our custom `FantasySoftAssertions`:

[source,java,indent=0]
----
@ExtendWith(SoftAssertionsExtension.class)
public class JUnit5_StandardAndCustomSoftAssertionsExamples {

  @Test
  public void successful_junit_soft_custom_assertion_example(FantasySoftAssertions softly) {
    softly.assertThat(frodo).hasName("Frodo")
                            .hasAge(33);
    softly.assertThat(frodo.age).isEqualTo(33);
  }
}
----



[[assertj-core-assumptions]]
==== Assumptions

Assumptions provide support for conditional test execution, if the assumptions are met the test is executed normally, if they don't the test is aborted and marked as ignored.

Assumptions are typically used whenever it does not make sense to continue execution of a given test method  a typical usage is running tests depending on a given OS/environment.

All AssertJ assumptions are static methods in the `Assumptions` class, they match the assertion API but are names `assumeThat` instead of `assertThat`.
You can also get assumptions through the `WithAssumptions` interface.

Example resulting in the test to be ignored:
[source,java,indent=0]
----
include::{testDir}/example/core/AssumptionsDemo.java[tags=assumption_not_met]
----

Example resulting in the test to be executed normally:
[source,java,indent=0]
----
include::{testDir}/example/core/AssumptionsDemo.java[tags=assumption_met]
----


[[assertj-core-javadoc]]
==== Javadoc

http://www.javadoc.io/doc/org.assertj/assertj-core/ is the latest version of assertj core javadoc, each assertion is explained, most of them with code examples so be sure to check it if you want to know what a specific assertion does. 